<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `BitVec` struct in crate `bitvec`."><meta name="keywords" content="rust, rustlang, rust-lang, BitVec"><title>bitvec::vec::BitVec - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Struct BitVec</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.add_assign_reverse">add_assign_reverse</a><a href="#method.add_reverse">add_reverse</a><a href="#method.append">append</a><a href="#method.as_bitslice">as_bitslice</a><a href="#method.as_mut_bitslice">as_mut_bitslice</a><a href="#method.bitptr">bitptr</a><a href="#method.capacity">capacity</a><a href="#method.change_cursor">change_cursor</a><a href="#method.clear">clear</a><a href="#method.drain">drain</a><a href="#method.from_bitslice">from_bitslice</a><a href="#method.from_boxed_bitslice">from_boxed_bitslice</a><a href="#method.from_element">from_element</a><a href="#method.from_raw_parts">from_raw_parts</a><a href="#method.from_slice">from_slice</a><a href="#method.from_vec">from_vec</a><a href="#method.insert">insert</a><a href="#method.into_boxed_bitslice">into_boxed_bitslice</a><a href="#method.into_boxed_slice">into_boxed_slice</a><a href="#method.into_vec">into_vec</a><a href="#method.new">new</a><a href="#method.pop">pop</a><a href="#method.push">push</a><a href="#method.remove">remove</a><a href="#method.reserve">reserve</a><a href="#method.reserve_exact">reserve_exact</a><a href="#method.resize">resize</a><a href="#method.retain">retain</a><a href="#method.set_elements">set_elements</a><a href="#method.set_len">set_len</a><a href="#method.shrink_to_fit">shrink_to_fit</a><a href="#method.splice">splice</a><a href="#method.split_off">split_off</a><a href="#method.swap_remove">swap_remove</a><a href="#method.truncate">truncate</a><a href="#method.with_capacity">with_capacity</a></div><a class="sidebar-title" href="#deref-methods">Methods from Deref&lt;Target=BitSlice&lt;C, T&gt;&gt;</a><div class="sidebar-links"><a href="#method.add_assign_reverse-1">add_assign_reverse</a><a href="#method.all">all</a><a href="#method.any">any</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_mut_slice">as_mut_slice</a><a href="#method.as_ptr">as_ptr</a><a href="#method.as_slice">as_slice</a><a href="#method.at">at</a><a href="#method.bitptr-1">bitptr</a><a href="#method.change_cursor-1">change_cursor</a><a href="#method.change_cursor_mut">change_cursor_mut</a><a href="#method.chunks">chunks</a><a href="#method.chunks_exact">chunks_exact</a><a href="#method.chunks_exact_mut">chunks_exact_mut</a><a href="#method.chunks_mut">chunks_mut</a><a href="#method.count_ones">count_ones</a><a href="#method.count_zeros">count_zeros</a><a href="#method.ends_with">ends_with</a><a href="#method.first">first</a><a href="#method.for_each">for_each</a><a href="#method.get">get</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.is_empty">is_empty</a><a href="#method.iter">iter</a><a href="#method.last">last</a><a href="#method.len">len</a><a href="#method.not_all">not_all</a><a href="#method.not_any">not_any</a><a href="#method.rchunks">rchunks</a><a href="#method.rchunks_exact">rchunks_exact</a><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a><a href="#method.rchunks_mut">rchunks_mut</a><a href="#method.reverse">reverse</a><a href="#method.rotate_left">rotate_left</a><a href="#method.rotate_right">rotate_right</a><a href="#method.set">set</a><a href="#method.set_all">set_all</a><a href="#method.set_unchecked">set_unchecked</a><a href="#method.some">some</a><a href="#method.split_at">split_at</a><a href="#method.split_at_mut">split_at_mut</a><a href="#method.split_first">split_first</a><a href="#method.split_first_mut">split_first_mut</a><a href="#method.split_last">split_last</a><a href="#method.split_last_mut">split_last_mut</a><a href="#method.starts_with">starts_with</a><a href="#method.swap">swap</a><a href="#method.windows">windows</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Add%3CBitVec%3CC%2C%20T%3E%3E">Add&lt;BitVec&lt;C, T&gt;&gt;</a><a href="#impl-AddAssign%3CBitVec%3CC%2C%20T%3E%3E">AddAssign&lt;BitVec&lt;C, T&gt;&gt;</a><a href="#impl-AsMut%3C%5BT%5D%3E">AsMut&lt;[T]&gt;</a><a href="#impl-AsMut%3CBitSlice%3CC%2C%20T%3E%3E">AsMut&lt;BitSlice&lt;C, T&gt;&gt;</a><a href="#impl-AsRef%3C%5BT%5D%3E">AsRef&lt;[T]&gt;</a><a href="#impl-AsRef%3CBitSlice%3CC%2C%20T%3E%3E">AsRef&lt;BitSlice&lt;C, T&gt;&gt;</a><a href="#impl-BitAnd%3CI%3E">BitAnd&lt;I&gt;</a><a href="#impl-BitAndAssign%3CI%3E">BitAndAssign&lt;I&gt;</a><a href="#impl-BitOr%3CI%3E">BitOr&lt;I&gt;</a><a href="#impl-BitOrAssign%3CI%3E">BitOrAssign&lt;I&gt;</a><a href="#impl-BitXor%3CI%3E">BitXor&lt;I&gt;</a><a href="#impl-BitXorAssign%3CI%3E">BitXorAssign&lt;I&gt;</a><a href="#impl-Borrow%3CBitSlice%3CC%2C%20T%3E%3E">Borrow&lt;BitSlice&lt;C, T&gt;&gt;</a><a href="#impl-BorrowMut%3CBitSlice%3CC%2C%20T%3E%3E">BorrowMut&lt;BitSlice&lt;C, T&gt;&gt;</a><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Deref">Deref</a><a href="#impl-DerefMut">DerefMut</a><a href="#impl-Display">Display</a><a href="#impl-Drop">Drop</a><a href="#impl-Eq">Eq</a><a href="#impl-Extend%3Cbool%3E">Extend&lt;bool&gt;</a><a href="#impl-From%3C%26%27_%20%5BT%5D%3E">From&lt;&amp;&#39;_ [T]&gt;</a><a href="#impl-From%3C%26%27_%20%5Bbool%5D%3E">From&lt;&amp;&#39;_ [bool]&gt;</a><a href="#impl-From%3C%26%27_%20BitSlice%3CC%2C%20T%3E%3E">From&lt;&amp;&#39;_ BitSlice&lt;C, T&gt;&gt;</a><a href="#impl-From%3CBitBox%3CC%2C%20T%3E%3E">From&lt;BitBox&lt;C, T&gt;&gt;</a><a href="#impl-From%3CBitVec%3CC%2C%20T%3E%3E">From&lt;BitVec&lt;C, T&gt;&gt;</a><a href="#impl-From%3CBox%3C%5BT%5D%3E%3E">From&lt;Box&lt;[T]&gt;&gt;</a><a href="#impl-From%3CVec%3CT%3E%3E">From&lt;Vec&lt;T&gt;&gt;</a><a href="#impl-FromIterator%3Cbool%3E">FromIterator&lt;bool&gt;</a><a href="#impl-Hash">Hash</a><a href="#impl-Index%3CRange%3Cusize%3E%3E">Index&lt;Range&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeFrom%3Cusize%3E%3E">Index&lt;RangeFrom&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeFull%3E">Index&lt;RangeFull&gt;</a><a href="#impl-Index%3CRangeInclusive%3Cusize%3E%3E">Index&lt;RangeInclusive&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeTo%3Cusize%3E%3E">Index&lt;RangeTo&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeToInclusive%3Cusize%3E%3E">Index&lt;RangeToInclusive&lt;usize&gt;&gt;</a><a href="#impl-Index%3Cusize%3E">Index&lt;usize&gt;</a><a href="#impl-IndexMut%3CRange%3Cusize%3E%3E">IndexMut&lt;Range&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E">IndexMut&lt;RangeFrom&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeFull%3E">IndexMut&lt;RangeFull&gt;</a><a href="#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E">IndexMut&lt;RangeInclusive&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeTo%3Cusize%3E%3E">IndexMut&lt;RangeTo&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E">IndexMut&lt;RangeToInclusive&lt;usize&gt;&gt;</a><a href="#impl-Into%3CBox%3C%5BT%5D%3E%3E">Into&lt;Box&lt;[T]&gt;&gt;</a><a href="#impl-Into%3CVec%3CT%3E%3E">Into&lt;Vec&lt;T&gt;&gt;</a><a href="#impl-IntoIterator">IntoIterator</a><a href="#impl-Neg">Neg</a><a href="#impl-Not">Not</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E">PartialEq&lt;&amp;&#39;_ BitSlice&lt;C, D&gt;&gt;</a><a href="#impl-PartialEq%3CBitSlice%3CC%2C%20D%3E%3E">PartialEq&lt;BitSlice&lt;C, D&gt;&gt;</a><a href="#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E">PartialEq&lt;BitVec&lt;C, D&gt;&gt;</a><a href="#impl-PartialOrd%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E">PartialOrd&lt;&amp;&#39;_ BitSlice&lt;C, D&gt;&gt;</a><a href="#impl-PartialOrd%3CBitSlice%3CC%2C%20D%3E%3E">PartialOrd&lt;BitSlice&lt;C, D&gt;&gt;</a><a href="#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E">PartialOrd&lt;BitVec&lt;C, D&gt;&gt;</a><a href="#impl-Send">Send</a><a href="#impl-Shl%3Cusize%3E">Shl&lt;usize&gt;</a><a href="#impl-ShlAssign%3Cusize%3E">ShlAssign&lt;usize&gt;</a><a href="#impl-Shr%3Cusize%3E">Shr&lt;usize&gt;</a><a href="#impl-ShrAssign%3Cusize%3E">ShrAssign&lt;usize&gt;</a><a href="#impl-Sub%3CBitVec%3CC%2C%20T%3E%3E">Sub&lt;BitVec&lt;C, T&gt;&gt;</a><a href="#impl-SubAssign%3CBitVec%3CC%2C%20T%3E%3E">SubAssign&lt;BitVec&lt;C, T&gt;&gt;</a><a href="#impl-Sync">Sync</a><a href="#impl-Write">Write</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-IntoIterator">IntoIterator</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-ToString">ToString</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class='location'><a href='../index.html'>bitvec</a>::<wbr><a href='index.html'>vec</a></p><script>window.sidebarCurrent = {name: 'BitVec', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/bitvec/vec.rs.html#337-345' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='../index.html'>bitvec</a>::<wbr><a href='index.html'>vec</a>::<wbr><a class="struct" href=''>BitVec</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'><span class="docblock attributes top-attr">#[repr(C)]
</span>pub struct BitVec&lt;C&nbsp;=&nbsp;<a class="struct" href="../../bitvec/cursor/struct.BigEndian.html" title="struct bitvec::cursor::BigEndian">BigEndian</a>, T&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span> { /* fields omitted */ }</pre></div><div class='docblock'><p>A compact <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> of bits, whose cursor and storage type can be customized.</p>
<p><code>BitVec</code> is a newtype wrapper over <code>Vec</code>, and as such is exactly three words in
size on the stack.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">new</span>();
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">false</span>);
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">0</span>], <span class="bool-val">false</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="bool-val">true</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">1</span>);

<span class="ident">bv</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">0</span>], <span class="bool-val">true</span>);

<span class="ident">bv</span>.<span class="ident">extend</span>([<span class="number">0u8</span>, <span class="number">1</span>, <span class="number">0</span>].<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">n</span> <span class="op">!</span><span class="op">=</span> <span class="number">0u8</span>));
<span class="kw">for</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">bv</span> {
  <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bit</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
<p>The <a href="../macro.bitvec.html"><code>bitvec!</code></a> macro is provided to make initialization more convenient.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
<p>It can also initialize each element of a <code>BitVec&lt;_, T&gt;</code> with a given value. This
may be more efficient than performing allocation and initialization in separate
steps, especially when initializing a vector of zeros:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">15</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="comment">// The following is equivalent, but potentially slower:</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv1</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">with_capacity</span>(<span class="number">15</span>);
<span class="ident">bv1</span>.<span class="ident">resize</span>(<span class="number">15</span>, <span class="bool-val">false</span>);</pre></div>
<p>Use a <code>BitVec&lt;T&gt;</code> as an efficient stack:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stack</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">new</span>();

<span class="ident">stack</span>.<span class="ident">push</span>(<span class="bool-val">false</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);

<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">top</span>) <span class="op">=</span> <span class="ident">stack</span>.<span class="ident">pop</span>() {
  <span class="comment">//  Prints true, true, false</span>
  <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">top</span>);
}</pre></div>
<h1 id="indexing" class="section-header"><a href="#indexing">Indexing</a></h1>
<p>The <code>BitVec</code> type allows you to access values by index, because it implements
the <a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code>Index</code></a> trait. An example will be more explicit:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>[<span class="number">1</span>]); <span class="comment">// it will display &#39;false&#39;</span></pre></div>
<p>However, be careful: if you try to access an index which isn’t in the <code>BitVec</code>,
your software will panic! You cannot do this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>[<span class="number">6</span>]); <span class="comment">// it will panic!</span></pre></div>
<p>In conclusion: always check if the index you want to get really exists before
doing it.</p>
<h1 id="slicing" class="section-header"><a href="#slicing">Slicing</a></h1>
<p>A <code>BitVec</code> is growable. A <a href="../struct.BitSlice.html"><code>BitSlice</code></a>, on the other hand, is fixed size. To get
a bit slice, use <code>&amp;</code>. Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">fn</span> <span class="ident">read_bitslice</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span>) {
	<span class="comment">// use slice</span>
}

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>];
<span class="ident">read_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">bv</span>);

<span class="comment">// … and that’s all!</span>
<span class="comment">// you can also do it like this:</span>
<span class="kw">let</span> <span class="ident">bs</span> : <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">bv</span>;</pre></div>
<p>In Rust, it’s more common to pass slices as arguments rather than vectors when
you do not want to grow or shrink it. The same goes for <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> and [<code>&amp;[]</code>], and
<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code>String</code></a> and <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code>&amp;str</code></a>.</p>
<h1 id="capacity-and-reallocation" class="section-header"><a href="#capacity-and-reallocation">Capacity and Reallocation</a></h1>
<p>The capacity of a bit vector is the amount of space allocated for any future
bits that will be added onto the vector. This is not to be confused with the
<em>length</em> of a vector, which specifies the number of live, useful bits within the
vector. If a vector’s length exceeds its capacity, its capacity will
automatically be increased, but its storage elements will have to be
reallocated.</p>
<p>For example, a bit vector with capacity 10 and length 0 would be an allocated,
but uninhabited, vector, with space for ten more bits. Pushing ten or fewer bits
onto the vector will not change its capacity or cause reallocation to occur.
However, if the vector’s length is increased to eleven, it will have to
reallocate, which can be slow. For this reason, it is recommended to use
<a href="#method.with_capacity"><code>BitVec::with_capacity</code></a> whenever possible to specify how big the bit vector is
expected to get.</p>
<h1 id="guarantees" class="section-header"><a href="#guarantees">Guarantees</a></h1>
<p>Due to its incredibly fundamental nature, <code>BitVec</code> makes a lot of guarantees
about its design. This ensures that it is as low-overhead as possible in the
general case, and can be correctly manipulated in fundamental ways by <code>unsafe</code>
code.</p>
<p>Most fundamentally, <code>BitVec</code> is and always will be a <code>([</code>BitPtr<code>], capacity)</code>
doublet. No more, no less. The order of these fields is unspecified, and you
should <strong>only</strong> interact with the members through the provided APIs. Note that
<code>BitPtr</code> is <em><strong>not directly manipulable</strong></em>, and must <em><strong>never</strong></em> be written or
interpreted as anything but opaque binary data by user code.</p>
<p>When a <code>BitVec</code> has allocated memory, then the memory to which it points is on
the heap (as defined by the allocator Rust is configured to use by default), and
its pointer points to <a href="#method.len"><code>len</code></a> initialized bits in order of the <a href="../trait.Cursor.html"><code>Cursor</code></a> type
parameter, followed by <code>capacity - len</code> logically uninitialized bits.</p>
<p><code>BitVec</code> will never perform a “small optimization” where elements are stored in
its handle representation, for two reasons:</p>
<ul>
<li>
<p>It would make it more difficult for user code to correctly manipulate a
<code>BitVec</code>. The contents of the <code>BitVec</code> would not have a stable address if the
handle were moved, and it would be more difficult to determine if a <code>BitVec</code>
had allocated memory.</p>
</li>
<li>
<p>It would penalize the general, heap-allocated, case by incurring a branch on
every access.</p>
</li>
</ul>
<p><code>BitVec</code> will never automatically shrink itself, even if it is emptied. This
ensures that no unnecessary allocations or deallocations occur. Emptying a
<code>BitVec</code> and then refilling it to the same length will incur no calls to the
allocator. If you wish to free up unused memory, use <a href="#method.shrink_to_fit"><code>shrink_to_fit</code></a>.</p>
<h2 id="erasure" class="section-header"><a href="#erasure">Erasure</a></h2>
<p><code>BitVec</code> will not specifically overwrite any data that is removed from it, nor
will it specifically preserve it. Its uninitialized memory is scratch space that
may be used however the implementation desires, and must not be relied upon as
stable. Do not rely on removed data to be erased for security purposes. Even if
you drop a <code>BitVec</code>, its buffer may simply be reused for other data structures
in your program. Even if you zero a <code>BitVec</code>’s memory first, that may not
actually occur if the optimizer does not consider this an observable side
effect. There is one case that will never break, however: using <code>unsafe</code> to
construct a <code>[T]</code> slice over the <code>BitVec</code>’s capacity, and writing to the excess
space, then increasing the length to match, is always valid.</p>
<h1 id="type-parameters" class="section-header"><a href="#type-parameters">Type Parameters</a></h1>
<ul>
<li><code>C: Cursor</code>: An implementor of the <a href="../trait.Cursor.html"><code>Cursor</code></a> trait. This type is used to
convert semantic indices into concrete bit positions in elements, and store or
retrieve bit values from the storage type.</li>
<li><code>T: BitStore</code>: An implementor of the <a href="../trait.BitStore.html"><code>BitStore</code></a> trait: <code>u8</code>, <code>u16</code>, <code>u32</code>,
or <code>u64</code> (64-bit systems only). This is the actual type in memory that the
vector will use to store data.</li>
</ul>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>The <code>BitVec</code> handle has the same <em>size</em> as standard Rust <code>Vec</code> handles, but it
is <em><strong>extremely binary incompatible</strong></em> with them. Attempting to treat
<code>BitVec&lt;_, T&gt;</code> as <code>Vec&lt;T&gt;</code> in any manner except through the provided APIs is
<em><strong>catastrophically</strong></em> unsafe and unsound.</p>
<p>[<code>&amp;[]</code>]: https://doc.rust-lang.org/stable/std/primitive.slice.html</p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#347-1689' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.new' class="method"><code id='new.v'>pub fn <a href='#method.new' class='fnname'>new</a>() -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#366-372' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new, empty, <code>BitVec&lt;C, T&gt;</code>.</p>
<p>The vector does not allocate until bits are written into it.</p>
<h1 id="returns" class="section-header"><a href="#returns">Returns</a></h1>
<p>An empty, unallocated, <code>BitVec</code> handle.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">new</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>(), <span class="number">0</span>);</pre></div>
</div><h4 id='method.with_capacity' class="method"><code id='with_capacity.v'>pub fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#397-414' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a new, empty, <code>BitVec&lt;T&gt;</code> with the specified capacity.</p>
<p>The new vector will be able to hold at least <code>capacity</code> elements before
it reallocates. If <code>capacity</code> is <code>0</code>, it will not allocate.</p>
<h1 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h1>
<ul>
<li><code>capacity</code>: The minimum number of bits that the new vector will need
to be able to hold.</li>
</ul>
<h1 id="returns-1" class="section-header"><a href="#returns-1">Returns</a></h1>
<p>An empty vector with at least the given capacity.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">with_capacity</span>(<span class="number">10</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">10</span>);</pre></div>
</div><h4 id='method.from_element' class="method"><code id='from_element.v'>pub fn <a href='#method.from_element' class='fnname'>from_element</a>(elt: T) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#436-442' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a <code>BitVec</code> from a single element.</p>
<p>The produced <code>BitVec</code> will span the element, and include all bits in it.</p>
<h1 id="parameters-1" class="section-header"><a href="#parameters-1">Parameters</a></h1>
<ul>
<li><code>elt</code>: The source element.</li>
</ul>
<h1 id="returns-2" class="section-header"><a href="#returns-2">Returns</a></h1>
<p>A <code>BitVec</code> over the provided element.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">from_element</span>(<span class="number">5</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">count_ones</span>(), <span class="number">2</span>);</pre></div>
</div><h4 id='method.from_slice' class="method"><code id='from_slice.v'>pub fn <a href='#method.from_slice' class='fnname'>from_slice</a>(slice: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[T]</a>) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#468-470' title='goto source code'>[src]</a></h4><div class='docblock'><p>Constructs a <code>BitVec</code> from a slice of elements.</p>
<p>The produced <code>BitVec</code> will span the provided slice.</p>
<h1 id="parameters-2" class="section-header"><a href="#parameters-2">Parameters</a></h1>
<ul>
<li><code>slice</code>: The source elements to copy into the new <code>BitVec</code>.</li>
</ul>
<h1 id="returns-3" class="section-header"><a href="#returns-3">Returns</a></h1>
<p>A <code>BitVec</code> set to the provided slice values.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">5</span>, <span class="number">10</span>];
<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[..]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">5</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">7</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">12</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">14</span>]);</pre></div>
</div><h4 id='method.from_vec' class="method"><code id='from_vec.v'>pub fn <a href='#method.from_vec' class='fnname'>from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#498-515' title='goto source code'>[src]</a></h4><div class='docblock'><p>Consumes a <code>Vec&lt;T&gt;</code> and creates a <code>BitVec&lt;C, T&gt;</code> from it.</p>
<h1 id="parameters-3" class="section-header"><a href="#parameters-3">Parameters</a></h1>
<ul>
<li><code>vec</code>: The source vector whose memory will be used.</li>
</ul>
<h1 id="returns-4" class="section-header"><a href="#returns-4">Returns</a></h1>
<p>A new <code>BitVec</code> using the <code>vec</code> <code>Vec</code>’s memory.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>Panics if the source vector would cause the <code>BitVec</code> to overflow
capacity.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">from_vec</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="string">&quot;[00000001, 00000010, 00000100, 00001000]&quot;</span>,
  <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>),
);</pre></div>
</div><h4 id='method.from_bitslice' class="method"><code id='from_bitslice.v'>pub fn <a href='#method.from_bitslice' class='fnname'>from_bitslice</a>(slice: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#537-539' title='goto source code'>[src]</a></h4><div class='docblock'><p>Clones a <code>&amp;BitSlice</code> into a <code>BitVec</code>.</p>
<h1 id="parameters-4" class="section-header"><a href="#parameters-4">Parameters</a></h1>
<ul>
<li><code>slice</code></li>
</ul>
<h1 id="returns-5" class="section-header"><a href="#returns-5">Returns</a></h1>
<p>A <code>BitVec</code> containing the same bits as the source slice.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> [<span class="number">0u8</span>, <span class="op">!</span><span class="number">0</span>].<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">from_bitslice</span>(<span class="ident">bs</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">16</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">some</span>());</pre></div>
</div><h4 id='method.from_boxed_bitslice' class="method"><code id='from_boxed_bitslice.v'>pub fn <a href='#method.from_boxed_bitslice' class='fnname'>from_boxed_bitslice</a>(slice: <a class="struct" href="../../bitvec/boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;C, T&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#562-566' title='goto source code'>[src]</a></h4><div class='docblock'><p>Converts a frozen <code>BitBox</code> allocation into a growable <code>BitVec</code>.</p>
<p>This does not copy or reallocate.</p>
<h1 id="parameters-5" class="section-header"><a href="#parameters-5">Parameters</a></h1>
<ul>
<li><code>slice</code>: A <code>BitBox</code> to be thawed.</li>
</ul>
<h1 id="returns-6" class="section-header"><a href="#returns-6">Returns</a></h1>
<p>A growable collection over the original memory of the slice.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">from_boxed_bitslice</span>(<span class="macro">bitbox</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">some</span>());</pre></div>
</div><h4 id='method.from_raw_parts' class="method"><code id='from_raw_parts.v'>pub unsafe fn <a href='#method.from_raw_parts' class='fnname'>from_raw_parts</a>(pointer: BitPtr&lt;T&gt;, capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#603-609' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a new <code>BitVec&lt;C, T&gt;</code> directly from the raw parts of another.</p>
<h1 id="parameters-6" class="section-header"><a href="#parameters-6">Parameters</a></h1>
<ul>
<li><code>pointer</code>: The <code>BitPtr&lt;T&gt;</code> to use.</li>
<li><code>capacity</code>: The number of <code>T</code> elements <em>allocated</em> in that slab.</li>
</ul>
<h1 id="returns-7" class="section-header"><a href="#returns-7">Returns</a></h1>
<p>A <code>BitVec</code> over the given slab of memory.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>This is <em><strong>highly</strong></em> unsafe, due to the number of invariants that aren’t
checked:</p>
<ul>
<li><code>pointer</code> needs to have been previously allocated by some allocating
type.</li>
<li><code>pointer</code>’s <code>T</code> needs to have the same size <em><strong>and alignment</strong></em> as it
was initially allocated.</li>
<li><code>pointer</code>’s element count needs to be less than or equal to the
original allocation capacity.</li>
<li><code>capacity</code> needs to be the original allocation capacity for the
vector. This is <em>not</em> the value produced by <code>.capacity()</code>.</li>
</ul>
<p>Violating these <em><strong>will</strong></em> cause problems, like corrupting the handle’s
concept of memory, the allocator’s internal data structures, and the
sanity of your program. It is <em><strong>absolutely</strong></em> not safe to construct a
<code>BitVec</code> whose <code>T</code> differs from the type used for the initial
allocation.</p>
<p>The ownership of <code>pointer</code> is effectively transferred to the
<code>BitVec&lt;C, T&gt;</code> which may then deallocate, reallocate, or modify the
contents of the referent slice at will. Ensure that nothing else uses
the pointer after calling this function.</p>
</div><h4 id='method.capacity' class="method"><code id='capacity.v'>pub fn <a href='#method.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#630-634' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the number of bits the vector can hold without reallocating.</p>
<h1 id="parameters-7" class="section-header"><a href="#parameters-7">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-8" class="section-header"><a href="#returns-8">Returns</a></h1>
<p>The number of bits that the vector can hold before reallocating.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">with_capacity</span>(<span class="number">10</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">10</span>);</pre></div>
</div><h4 id='method.reserve' class="method"><code id='reserve.v'>pub fn <a href='#method.reserve' class='fnname'>reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#662-674' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reserves capacity for at least <code>additional</code> more bits to be inserted.</p>
<p>The collection may reserve more space to avoid frequent reallocations.
After calling <code>reserve</code>, capacity will be greater than or equal to
<code>self.len() + additional</code>. Does nothing if the capacity is already
sufficient.</p>
<h1 id="parameters-8" class="section-header"><a href="#parameters-8">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>additional</code>: The number of extra bits to be granted space.</li>
</ul>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>Panics if the new capacity would overflow the vector’s limits.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">5</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">5</span>);
<span class="ident">bv</span>.<span class="ident">reserve</span>(<span class="number">10</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">15</span>);</pre></div>
</div><h4 id='method.reserve_exact' class="method"><code id='reserve_exact.v'>pub fn <a href='#method.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#705-717' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reserves the minimum capacity for at least <code>additional</code> more bits.</p>
<p>After calling <code>reserve_exact</code>, the capacity will be greater than or
equal to <code>self.len() + additional</code>. Does nothing if the capacity is
already sufficient.</p>
<p>Note that the allocator may give the collection more space than it
requests. Therefore, the capacity cannot be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>
<h1 id="parameters-9" class="section-header"><a href="#parameters-9">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>additional</code>: The number of extra bits to be granted space.</li>
</ul>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>Panics if the new capacity would overflow the vector’s limits.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">5</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">5</span>);
<span class="ident">bv</span>.<span class="ident">reserve_exact</span>(<span class="number">10</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">15</span>);</pre></div>
</div><h4 id='method.shrink_to_fit' class="method"><code id='shrink_to_fit.v'>pub fn <a href='#method.shrink_to_fit' class='fnname'>shrink_to_fit</a>(&amp;mut self)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#743-745' title='goto source code'>[src]</a></h4><div class='docblock'><p>Shrinks the capacity of the vector as much as possible.</p>
<p>It will drop down as close as possible to the length, but the allocator
may still inform the vector that there is space for bits.</p>
<p>This does not modify the contents of the memory store! It will not zero
any memory that had been used and then removed from the vector’s live
count.</p>
<h1 id="parameters-10" class="section-header"><a href="#parameters-10">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">100</span>];
<span class="kw">let</span> <span class="ident">cap</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">capacity</span>();
<span class="ident">bv</span>.<span class="ident">truncate</span>(<span class="number">10</span>);
<span class="ident">bv</span>.<span class="ident">shrink_to_fit</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="ident">cap</span>);</pre></div>
</div><h4 id='method.truncate' class="method"><code id='truncate.v'>pub fn <a href='#method.truncate' class='fnname'>truncate</a>(&amp;mut self, len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#769-773' title='goto source code'>[src]</a></h4><div class='docblock'><p>Shortens the vector, keeping the first <code>len</code> bits and dropping the rest.</p>
<p>If <code>len</code> is greater than the vector’s current length, this has no
effect.</p>
<h1 id="parameters-11" class="section-header"><a href="#parameters-11">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>len</code>: The new length of the vector.</li>
</ul>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">15</span>];
<span class="ident">bv</span>.<span class="ident">truncate</span>(<span class="number">10</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">10</span>);

<span class="ident">bv</span>.<span class="ident">truncate</span>(<span class="number">15</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">10</span>);</pre></div>
</div><h4 id='method.as_bitslice' class="method"><code id='as_bitslice.v'>pub fn <a href='#method.as_bitslice' class='fnname'>as_bitslice</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#795-797' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a <code>BitSlice</code> containing the entire vector.</p>
<p>Equivalent to <code>&amp;s[..]</code>.</p>
<h1 id="parameters-12" class="section-header"><a href="#parameters-12">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-9" class="section-header"><a href="#returns-9">Returns</a></h1>
<p>A <code>BitSlice</code> over the vector.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">as_bitslice</span>();</pre></div>
</div><h4 id='method.as_mut_bitslice' class="method"><code id='as_mut_bitslice.v'>pub fn <a href='#method.as_mut_bitslice' class='fnname'>as_mut_bitslice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#819-821' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a mutable <code>BitSlice</code> containing the entire vector.</p>
<p>Equivalent to <code>&amp;mut s[..]</code>.</p>
<h1 id="parameters-13" class="section-header"><a href="#parameters-13">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="returns-10" class="section-header"><a href="#returns-10">Returns</a></h1>
<p>A mutable <code>BitSlice</code> over the vector.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">as_mut_bitslice</span>();</pre></div>
</div><h4 id='method.set_len' class="method"><code id='set_len.v'>pub unsafe fn <a href='#method.set_len' class='fnname'>set_len</a>(&amp;mut self, len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#854-868' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sets the length of the vector.</p>
<p>This unconditionally sets the size of the vector, without modifying its
contents. It is up to the caller to ensure that the vector’s buffer can
hold the new size.</p>
<h1 id="parameters-14" class="section-header"><a href="#parameters-14">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>len</code>: The new length of the vector. This must be less than the
maximum number of bits that the vector can hold.</li>
</ul>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>This panics if <code>len</code> overflows the vector's intrinsic <em>or allocated</em>
capacities.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>The caller must ensure that the new length is sound for the vector.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">with_capacity</span>(<span class="number">15</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="kw">unsafe</span> { <span class="ident">bv</span>.<span class="ident">set_len</span>(<span class="number">10</span>) };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">10</span>);</pre></div>
</div><h4 id='method.swap_remove' class="method"><code id='swap_remove.v'>pub fn <a href='#method.swap_remove' class='fnname'>swap_remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#900-906' title='goto source code'>[src]</a></h4><div class='docblock'><p>Removes a bit from the vector and returns it.</p>
<p>The removed bit is replaced by the last bit in the vector.</p>
<h1 id="parameters-15" class="section-header"><a href="#parameters-15">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The index whose bit is to be returned, and replaced by the
tail.</li>
</ul>
<h1 id="returns-11" class="section-header"><a href="#returns-11">Returns</a></h1>
<p>The bit at the requested index.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>Panics if the index is out of bounds.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bv</span>[<span class="number">2</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">5</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bv</span>.<span class="ident">swap_remove</span>(<span class="number">2</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">2</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">4</span>);</pre></div>
</div><h4 id='method.insert' class="method"><code id='insert.v'>pub fn <a href='#method.insert' class='fnname'>insert</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#935-940' title='goto source code'>[src]</a></h4><div class='docblock'><p>Inserts a bit at a position, shifting all bits after it to the right.</p>
<p>Note that this is <code>O(n)</code> runtime.</p>
<h1 id="parameters-16" class="section-header"><a href="#parameters-16">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The position at which to insert. This may be any value from
<code>0</code> up to <em>and including</em> <code>self.len()</code>. At <code>self.len()</code>, it is
equivalent to calling <code>self.push(value)</code>.</li>
<li><code>value</code>: The bit to be inserted.</li>
</ul>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>Panics if <code>index</code> is greater than the length.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="ident">bv</span>.<span class="ident">insert</span>(<span class="number">2</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="ident">bv</span>.<span class="ident">insert</span>(<span class="number">5</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.remove' class="method"><code id='remove.v'>pub fn <a href='#method.remove' class='fnname'>remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#968-974' title='goto source code'>[src]</a></h4><div class='docblock'><p>Removes and returns the bit at position <code>index</code>, shifting all bits after
it to the left.</p>
<h1 id="parameters-17" class="section-header"><a href="#parameters-17">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The position whose bit is to be removed. This must be in the
domain <code>0 .. self.len()</code>.</li>
</ul>
<h1 id="returns-12" class="section-header"><a href="#returns-12">Returns</a></h1>
<p>The bit at the requested index.</p>
<h1 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h1>
<p>Panics if <code>index</code> is out of bounds for the vector.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">remove</span>(<span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id='method.retain' class="method"><code id='retain.v'>pub fn <a href='#method.retain' class='fnname'>retain</a>&lt;F&gt;(&amp;mut self, pred: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1005-1012' title='goto source code'>[src]</a></h4><div class='docblock'><p>Retains only the bits that pass the predicate.</p>
<p>This removes all bits <code>b</code> where <code>f(e)</code> returns <code>false</code>. This method
operates in place and preserves the order of the retained bits. Because
it is in-place, it operates in <code>O(n²)</code> time.</p>
<h1 id="parameters-18" class="section-header"><a href="#parameters-18">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>pred</code>: The testing predicate for each bit.</li>
</ul>
<h1 id="type-parameters-1" class="section-header"><a href="#type-parameters-1">Type Parameters</a></h1>
<ul>
<li><code>F: FnMut(usize, bool) -&gt; bool</code>: A function that can be invoked on
each bit, returning whether the bit should be kept or not. Receives
the index (following <a href="../slice/struct.BitSlice.html#method.for_each"><code>BitSlice::for_each</code></a>) to provide additional
context to determine whether the entry satisfies the condition.</li>
</ul>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">retain</span>(<span class="op">|</span><span class="kw">_</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">b</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.push' class="method"><code id='push.v'>pub fn <a href='#method.push' class='fnname'>push</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1039-1056' title='goto source code'>[src]</a></h4><div class='docblock'><p>Appends a bit to the back of the vector.</p>
<p>If the vector is at capacity, this may cause a reallocation.</p>
<h1 id="parameters-19" class="section-header"><a href="#parameters-19">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>value</code>: The bit value to append.</li>
</ul>
<h1 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h1>
<p>This will panic if the push will cause the vector to allocate above
<code>BitPtr&lt;T&gt;</code> or machine capacity.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">new</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">1</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">0</span>]);</pre></div>
</div><h4 id='method.pop' class="method"><code id='pop.v'>pub fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1084-1091' title='goto source code'>[src]</a></h4><div class='docblock'><p>Removes the last bit from the collection, if present.</p>
<h1 id="parameters-20" class="section-header"><a href="#parameters-20">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="returns-13" class="section-header"><a href="#returns-13">Returns</a></h1>
<p>If the vector is not empty, this returns the last bit; if it is empty,
this returns <code>None</code>.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">new</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">1</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>[<span class="number">0</span>]);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">pop</span>().<span class="ident">unwrap</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">pop</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.append' class="method"><code id='append.v'>pub fn <a href='#method.append' class='fnname'>append</a>&lt;D, U&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;D, U&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1117-1121' title='goto source code'>[src]</a></h4><div class='docblock'><p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>
<h1 id="parameters-21" class="section-header"><a href="#parameters-21">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>other</code>: A <code>BitVec</code> of any order and storage type. Its bits are
appended to <code>self</code>.</li>
</ul>
<h1 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h1>
<p>Panics if the joined vector is too large.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv1</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv2</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">10</span>];
<span class="ident">bv1</span>.<span class="ident">append</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">bv2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv1</span>.<span class="ident">len</span>(), <span class="number">20</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv1</span>[<span class="number">10</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv2</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id='method.drain' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/vec/struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/vec/struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/vec/struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>;</span></code></div></div><code id='drain.v'>pub fn <a href='#method.drain' class='fnname'>drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="../../bitvec/vec/struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1160-1193' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a draining iterator that removes the specified range from the
vector and yields the removed bits.</p>
<h1 id="notes" class="section-header"><a href="#notes">Notes</a></h1>
<ol>
<li>The element range is removed, regardless of whether the iterator is
consumed.</li>
<li>The amount of items removed from the vector if the draining iterator
is leaked, is left unspecified.</li>
</ol>
<h1 id="parameters-22" class="section-header"><a href="#parameters-22">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>range</code>: any range literal, which is used to define the range of the
vector that is drained.</li>
</ul>
<h1 id="returns-14" class="section-header"><a href="#returns-14">Returns</a></h1>
<p>An iterator over the specified range.</p>
<h1 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h1>
<p>Panics if the range is ill-formed, or if it is beyond the vector bounds.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">7</span>);
<span class="kw">for</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">bv</span>.<span class="ident">drain</span>(<span class="number">2</span> .. <span class="number">5</span>) {
  <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bit</span>);
}
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">not_any</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">4</span>);</pre></div>
</div><h4 id='method.clear' class="method"><code id='clear.v'>pub fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1223-1225' title='goto source code'>[src]</a></h4><div class='docblock'><p>Clears the vector, removing all values.</p>
<p>Note that this method has no effect on the allocated capacity of the
vector.</p>
<h1 id="parameters-23" class="section-header"><a href="#parameters-23">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="effects" class="section-header"><a href="#effects">Effects</a></h1>
<p>Becomes an uninhabited slice.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">30</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">iter</span>().<span class="ident">all</span>(<span class="op">|</span><span class="ident">b</span><span class="op">|</span> <span class="ident">b</span>));
<span class="ident">bv</span>.<span class="ident">clear</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());</pre></div>
<p>After calling <code>clear()</code>, <code>bv</code> will no longer show raw memory, so the
above test cannot show that the underlying memory is not altered. This
is also an implementation detail on which you should not rely.</p>
</div><h4 id='method.split_off' class="method"><code id='split_off.v'>pub fn <a href='#method.split_off' class='fnname'>split_off</a>(&amp;mut self, at: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1259-1275' title='goto source code'>[src]</a></h4><div class='docblock'><p>Splits the collection into two at the given index.</p>
<p>Returns a newly allocated <code>Self</code>. <code>self</code> contains elements <code>[0, at)</code>,
and the returned <code>Self</code> contains elements <code>[at, self.len())</code>.</p>
<p>Note that the capacity of <code>self</code> does not change.</p>
<h1 id="parameters-24" class="section-header"><a href="#parameters-24">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>at</code>: The index at which to perform the split. This must be in the
domain <code>0 ..= self.len()</code>. When it is <code>self.len()</code>, an empty vector is
returned.</li>
</ul>
<h1 id="returns-15" class="section-header"><a href="#returns-15">Returns</a></h1>
<p>A new <code>BitVec</code> containing all the elements from <code>at</code> onwards.</p>
<h1 id="panics-10" class="section-header"><a href="#panics-10">Panics</a></h1>
<p>Panics if <code>at</code> is beyond <code>self.len()</code>.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv1</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">bv2</span> <span class="op">=</span> <span class="ident">bv1</span>.<span class="ident">split_off</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv1</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv2</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.resize' class="method"><code id='resize.v'>pub fn <a href='#method.resize' class='fnname'>resize</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1300-1308' title='goto source code'>[src]</a></h4><div class='docblock'><p>Resizes the <code>BitVec</code> in place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p>If <code>new_len</code> is greater than <code>len</code>, then  the vector is extended by the
difference, and filled with the provided value. If <code>new_len</code> is less
than <code>len</code>, then the vector is just truncated.</p>
<h1 id="parameters-25" class="section-header"><a href="#parameters-25">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>new_len</code>: The new length of the vector.</li>
<li><code>value</code>: The fill value if the vector is to be extended.</li>
</ul>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">4</span>];
<span class="ident">bv</span>.<span class="ident">resize</span>(<span class="number">8</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="ident">bv</span>.<span class="ident">resize</span>(<span class="number">5</span>, <span class="bool-val">false</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.splice' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/vec/struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'a, C, T, I&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/vec/struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'a, C, T, I&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/vec/struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'a, C, T, I&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>;</span></code></div></div><code id='splice.v'>pub fn <a href='#method.splice' class='fnname'>splice</a>&lt;R, I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;range: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;replacement: I<br>) -&gt; <a class="struct" href="../../bitvec/vec/struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;C, T, &lt;I as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1364-1374' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a splicing iterator that exchanges the specified range for the
<code>replacement</code> iterator, yielding the removed items. The range and its
replacement do not need to be the same size.</p>
<h1 id="notes-1" class="section-header"><a href="#notes-1">Notes</a></h1>
<ol>
<li>The element range is removed and replaced even if the iterator
produced by this method is not fully consumed.</li>
<li>It is unspecified how many bits are removed from the <code>BitVec</code> if the
returned iterator is leaked.</li>
<li>The input iterator <code>replacement</code> is only consumed when the returned
iterator is dropped.</li>
<li>This is optimal if:
<ul>
<li>the tail (elements in the <code>BitVec</code> after <code>range</code>) is empty,</li>
<li><code>replace_with</code> yields fewer characters than <code>range</code>’s length,</li>
<li>the lower bound of <code>replacement.size_hint()</code> is exact.</li>
</ul>
</li>
</ol>
<h1 id="parameters-26" class="section-header"><a href="#parameters-26">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>range</code>: A range of indices in the <code>BitVec</code> to pull out of the
collection.</li>
<li><code>replacement</code>: Something which can be used to provide new bits to
replace the removed range.</li>
</ul>
<p>The entirety of <code>replacement</code> will be inserted into the slot marked by
<code>range</code>. If <code>replacement</code> is an infinite iterator, then this will hang,
and crash your program.</p>
<h1 id="returns-16" class="section-header"><a href="#returns-16">Returns</a></h1>
<p>An iterator over the bits marked by <code>range</code>.</p>
<h1 id="panics-11" class="section-header"><a href="#panics-11">Panics</a></h1>
<p>Panics if the range is ill-formed, or extends past the end of the
<code>BitVec</code>.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<p>This example starts with six bits of zero, and then splices out bits 2
and 3 and replaces them with four bits of one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">6</span>];
<span class="kw">let</span> <span class="ident">bv2</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">4</span>];

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">splice</span>(<span class="number">2</span> .. <span class="number">4</span>, <span class="ident">bv2</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">BitVec</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id='method.set_elements' class="method"><code id='set_elements.v'>pub fn <a href='#method.set_elements' class='fnname'>set_elements</a>(&amp;mut self, element: T)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1402-1409' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sets the backing storage to the provided element.</p>
<p>This unconditionally sets each allocated element in the backing storage
to the provided value, without altering the <code>BitVec</code> length or capacity.
It operates on the underlying <code>Vec</code>’s memory region directly, and will
ignore the <code>BitVec</code>’s cursors.</p>
<p>This has the unobservable effect of setting the allocated, but dead,
bits beyond the end of the vector’s <em>length</em>, up to its <em>capacity</em>.</p>
<h1 id="parameters-27" class="section-header"><a href="#parameters-27">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>element</code>: The value to which each allocated element in the backing
store will be set.</li>
</ul>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="ident">bv</span>.<span class="ident">set_elements</span>(<span class="number">0xA5</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0xA5</span>, <span class="number">0xA5</span>]);</pre></div>
</div><h4 id='method.add_reverse' class="method"><code id='add_reverse.v'>pub fn <a href='#method.add_reverse' class='fnname'>add_reverse</a>&lt;I&gt;(self, addend: I) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1444-1448' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs “reverse” addition (left to right instead of right to left).</p>
<p>This addition traverses the addends from left to right, performing
the addition at each index and writing the sum into <code>self</code>.</p>
<p>If <code>addend</code> expires before <code>self</code> does, <code>addend</code> is zero-extended and
the carry propagates through the rest of <code>self</code>. If <code>self</code> expires
before <code>addend</code>, then <code>self</code> is zero-extended and the carry propagates
through the rest of <code>addend</code>, growing <code>self</code> until <code>addend</code> expires.</p>
<p>An infinite <code>addend</code> will cause unbounded memory growth until the vector
overflows and panics.</p>
<h1 id="parameters-28" class="section-header"><a href="#parameters-28">Parameters</a></h1>
<ul>
<li><code>self</code></li>
<li><code>addend: impl IntoIterator&lt;Item=bool&gt;</code>: A stream of bits to add into
<code>self</code>, from left to right.</li>
</ul>
<h1 id="returns-17" class="section-header"><a href="#returns-17">Returns</a></h1>
<p>The sum vector of <code>self</code> and <code>addend</code>.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">add_reverse</span>(<span class="ident">b</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">c</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.add_assign_reverse' class="method"><code id='add_assign_reverse.v'>pub fn <a href='#method.add_assign_reverse' class='fnname'>add_assign_reverse</a>&lt;I&gt;(&amp;mut self, addend: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1484-1502' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs “reverse” addition (left to right instead of right to left).</p>
<p>This addition traverses the addends from left to right, performing
the addition at each index and writing the sum into <code>self</code>.</p>
<p>If <code>addend</code> expires before <code>self</code> does, <code>addend</code> is zero-extended and
the carry propagates through the rest of <code>self</code>. If <code>self</code> expires
before <code>addend</code>, then <code>self</code> is zero-extended and the carry propagates
through the rest of <code>addend</code>, growing <code>self</code> until <code>addend</code> expires.</p>
<p>An infinite <code>addend</code> will cause unbounded memory growth until the vector
overflows and panics.</p>
<h1 id="parameters-29" class="section-header"><a href="#parameters-29">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>addend: impl IntoIterator&lt;Item=bool&gt;</code>: A stream of bits to add into
<code>self</code>, from left to right.</li>
</ul>
<h1 id="effects-1" class="section-header"><a href="#effects-1">Effects</a></h1>
<p><code>self</code> may grow as a result of the final carry-out bit being <code>1</code> and
pushed onto the right end.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span>     <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">a</span>.<span class="ident">add_assign_reverse</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.change_cursor' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span></code></div></div><code id='change_cursor.v'>pub fn <a href='#method.change_cursor' class='fnname'>change_cursor</a>&lt;D&gt;(self) -&gt; <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;D, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1518-1523' title='goto source code'>[src]</a></h4><div class='docblock'><p>Changes the cursor type on the vector handle, without changing its
contents.</p>
<h1 id="parameters-30" class="section-header"><a href="#parameters-30">Parameters</a></h1>
<ul>
<li><code>self</code></li>
</ul>
<h1 id="returns-18" class="section-header"><a href="#returns-18">Returns</a></h1>
<p>An equivalent vector handle with a new cursor type. The contents of the
backing storage are unchanged.</p>
<p>To reorder the bits in memory, drain this vector into a new handle with
the desired cursor type.</p>
</div><h4 id='method.into_boxed_bitslice' class="method"><code id='into_boxed_bitslice.v'>pub fn <a href='#method.into_boxed_bitslice' class='fnname'>into_boxed_bitslice</a>(self) -&gt; <a class="struct" href="../../bitvec/boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1534-1539' title='goto source code'>[src]</a></h4><div class='docblock'><p>Degrades a <code>BitVec</code> to a <code>BitBox</code>, freezing its size.</p>
<h1 id="parameters-31" class="section-header"><a href="#parameters-31">Parameters</a></h1>
<ul>
<li><code>self</code></li>
</ul>
<h1 id="returns-19" class="section-header"><a href="#returns-19">Returns</a></h1>
<p>Itself, with its size frozen and ungrowable.</p>
</div><h4 id='method.into_boxed_slice' class="method"><code id='into_boxed_slice.v'>pub fn <a href='#method.into_boxed_slice' class='fnname'>into_boxed_slice</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1550-1552' title='goto source code'>[src]</a></h4><div class='docblock'><p>Degrades a <code>BitVec</code> to a standard boxed slice.</p>
<h1 id="parameters-32" class="section-header"><a href="#parameters-32">Parameters</a></h1>
<ul>
<li><code>self</code></li>
</ul>
<h1 id="returns-20" class="section-header"><a href="#returns-20">Returns</a></h1>
<p>A boxed slice of the data the <code>BitVec</code> had owned.</p>
</div><h4 id='method.into_vec' class="method"><code id='into_vec.v'>pub fn <a href='#method.into_vec' class='fnname'>into_vec</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1563-1570' title='goto source code'>[src]</a></h4><div class='docblock'><p>Degrades a <code>BitVec</code> to a standard <code>Vec</code>.</p>
<h1 id="parameters-33" class="section-header"><a href="#parameters-33">Parameters</a></h1>
<ul>
<li><code>self</code></li>
</ul>
<h1 id="returns-21" class="section-header"><a href="#returns-21">Returns</a></h1>
<p>The plain vector underlying the <code>BitVec</code>.</p>
</div><h4 id='method.bitptr' class="method"><code id='bitptr.v'>pub fn <a href='#method.bitptr' class='fnname'>bitptr</a>(&amp;self) -&gt; BitPtr&lt;T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1603-1605' title='goto source code'>[src]</a></h4><div class='docblock'><p>Gets the raw <code>BitPtr</code> powering the vector.</p>
<h1 id="parameters-34" class="section-header"><a href="#parameters-34">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-22" class="section-header"><a href="#returns-22">Returns</a></h1>
<p>The underlying <code>BitPtr</code> for the vector.</p>
<h1 id="notes-2" class="section-header"><a href="#notes-2">Notes</a></h1>
<p>The <code>BitPtr&lt;T&gt;</code> return type is opaque, and not exported by the crate.
Users are not able to use it in any way except to construct another
<code>BitVec&lt;_, T&gt;</code> from it. It is not possible for user code to even express
the name of the type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">10</span>];
<span class="kw">let</span> <span class="ident">bitptr</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">bitptr</span>();
<span class="kw">let</span> <span class="ident">cap</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">capacity</span>();
<span class="ident">mem</span>::<span class="ident">forget</span>(<span class="ident">bv</span>);
<span class="kw">let</span> <span class="ident">bv2</span> <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_raw_parts</span>(<span class="ident">bitptr</span>, <span class="ident">cap</span>)
};
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv2</span>.<span class="ident">len</span>(), <span class="number">10</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bv2</span>[<span class="number">9</span>]);</pre></div>
</div></div><h2 id='deref-methods' class='small-section-header'>Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;&gt;<a href='#deref-methods' class='anchor'></a></h2><div class='impl-items'><h4 id='method.len' class="method"><code id='len.v'>pub fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#362-364' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the number of bits contained in the <code>BitSlice</code>.</p>
<h1 id="parameters-35" class="section-header"><a href="#parameters-35">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-23" class="section-header"><a href="#returns-23">Returns</a></h1>
<p>The number of live bits in the slice domain.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bs</span>.<span class="ident">len</span>(), <span class="number">8</span>);</pre></div>
</div><h4 id='method.is_empty' class="method"><code id='is_empty.v'>pub fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#386-388' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests if the slice is empty.</p>
<h1 id="parameters-36" class="section-header"><a href="#parameters-36">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-24" class="section-header"><a href="#returns-24">Returns</a></h1>
<p>Whether the slice has no live bits.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">empty</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bs</span>.<span class="ident">is_empty</span>());
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="number">0u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bs</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id='method.first' class="method"><code id='first.v'>pub fn <a href='#method.first' class='fnname'>first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#408-410' title='goto source code'>[src]</a></h4><div class='docblock'><p>Gets the first element of the slice, if present.</p>
<h1 id="parameters-37" class="section-header"><a href="#parameters-37">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-25" class="section-header"><a href="#returns-25">Returns</a></h1>
<p><code>None</code> if the slice is empty, or <code>Some(bit)</code> if it is not.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">empty</span>().<span class="ident">first</span>().<span class="ident">is_none</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="number">128u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>().<span class="ident">first</span>().<span class="ident">unwrap</span>());</pre></div>
</div><h4 id='method.split_first' class="method"><code id='split_first.v'>pub fn <a href='#method.split_first' class='fnname'>split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#444-451' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h1 id="parameters-38" class="section-header"><a href="#parameters-38">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-26" class="section-header"><a href="#returns-26">Returns</a></h1>
<p>If the slice is empty, this returns <code>None</code>, otherwise, it returns <code>Some</code>
of:</p>
<ul>
<li>the first bit</li>
<li>a <code>&amp;BitSlice</code> of all the rest of the bits (this may be empty)</li>
</ul>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">empty</span>().<span class="ident">split_first</span>().<span class="ident">is_none</span>());

<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="number">128u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">h</span>, <span class="ident">t</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first</span>().<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">t</span>.<span class="ident">not_any</span>());

<span class="kw">let</span> (<span class="ident">h</span>, <span class="ident">t</span>) <span class="op">=</span> <span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">1</span>].<span class="ident">split_first</span>().<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">t</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id='method.split_first_mut' class="method"><code id='split_first_mut.v'>pub fn <a href='#method.split_first_mut' class='fnname'>split_first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#481-488' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h1 id="parameters-39" class="section-header"><a href="#parameters-39">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-27" class="section-header"><a href="#returns-27">Returns</a></h1>
<p>If the slice is empty, this returns <code>None</code>, otherwise, it returns <code>Some</code>
of:</p>
<ul>
<li>the first bit</li>
<li>a <code>&amp;mut BitSlice</code> of all the rest of the bits (this may be empty)</li>
</ul>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">LittleEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span>]);
<span class="kw-2">*</span><span class="ident">bits</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
<span class="kw">let</span> (<span class="ident">h</span>, <span class="ident">t</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first_mut</span>().<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">t</span>.<span class="ident">len</span>(), <span class="number">7</span>);</pre></div>
</div><h4 id='method.split_last' class="method"><code id='split_last.v'>pub fn <a href='#method.split_last' class='fnname'>split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#522-530' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the last and all the rest of the bits in the slice, or <code>None</code>
if it is empty.</p>
<h1 id="parameters-40" class="section-header"><a href="#parameters-40">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-28" class="section-header"><a href="#returns-28">Returns</a></h1>
<p>If the slice is empty, this returns <code>None</code>, otherwise, it returns <code>Some</code>
of:</p>
<ul>
<li>the last bit</li>
<li>a <code>&amp;BitSlice</code> of all the rest of the bits (this may be empty)</li>
</ul>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">empty</span>().<span class="ident">split_last</span>().<span class="ident">is_none</span>());

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">1u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">t</span>, <span class="ident">h</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last</span>().<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">t</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>.<span class="ident">not_any</span>());

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">7</span> .. <span class="number">8</span>];
<span class="kw">let</span> (<span class="ident">t</span>, <span class="ident">h</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last</span>().<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">t</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id='method.split_last_mut' class="method"><code id='split_last_mut.v'>pub fn <a href='#method.split_last_mut' class='fnname'>split_last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#560-568' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the last and all the rest of the bits in the slice, or <code>None</code>
if it is empty.</p>
<h1 id="parameters-41" class="section-header"><a href="#parameters-41">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-29" class="section-header"><a href="#returns-29">Returns</a></h1>
<p>If the slice is empty, this returns <code>None</code>, otherwise, it returns <code>Some</code>
of:</p>
<ul>
<li>the last bit</li>
<li>a <code>&amp;BitSlice</code> of all the rest of the bits (this may be empty)</li>
</ul>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">LittleEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">7</span>]);
<span class="kw-2">*</span><span class="ident">bits</span>.<span class="ident">at</span>(<span class="number">7</span>) <span class="op">=</span> <span class="bool-val">true</span>;
<span class="kw">let</span> (<span class="ident">h</span>, <span class="ident">t</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last_mut</span>().<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">h</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">t</span>.<span class="ident">len</span>(), <span class="number">7</span>);</pre></div>
</div><h4 id='method.last' class="method"><code id='last.v'>pub fn <a href='#method.last' class='fnname'>last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#588-595' title='goto source code'>[src]</a></h4><div class='docblock'><p>Gets the last element of the slice, or <code>None</code> if it is empty.</p>
<h1 id="parameters-42" class="section-header"><a href="#parameters-42">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-30" class="section-header"><a href="#returns-30">Returns</a></h1>
<p><code>None</code> if the slice is empty, or <code>Some(bit)</code> if it is not.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">empty</span>().<span class="ident">last</span>().<span class="ident">is_none</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="number">1u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>().<span class="ident">last</span>().<span class="ident">unwrap</span>());</pre></div>
</div><h4 id='method.get' class="method"><code id='get.v'>pub fn <a href='#method.get' class='fnname'>get</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#619-626' title='goto source code'>[src]</a></h4><div class='docblock'><p>Gets the bit value at the given position.</p>
<h1 id="parameters-43" class="section-header"><a href="#parameters-43">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>index</code>: The bit index to retrieve.</li>
</ul>
<h1 id="returns-31" class="section-header"><a href="#returns-31">Returns</a></h1>
<p>The bit at the specified index, if any. If <code>index</code> is beyond the bounds
of <code>self</code>, then <code>None</code> is produced.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">8u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">4</span>).<span class="ident">unwrap</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">3</span>).<span class="ident">unwrap</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">10</span>).<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.get_unchecked' class="method"><code id='get_unchecked.v'>pub unsafe fn <a href='#method.get_unchecked' class='fnname'>get_unchecked</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#669-672' title='goto source code'>[src]</a></h4><div class='docblock'><p>Looks up a bit at an index, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.get"><code>get</code></a>.</p>
<h1 id="parameters-44" class="section-header"><a href="#parameters-44">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>index</code>: The bit index to retrieve. This index is <em>not</em> checked
against the length of <code>self</code>.</li>
</ul>
<h1 id="returns-32" class="section-header"><a href="#returns-32">Returns</a></h1>
<p>The bit at the requested index.</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and look up the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<p>This example uses a bit slice of length 2, and demonstrates
out-of-bounds access to the last bit in the element.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>()[<span class="number">2</span> .. <span class="number">4</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">get_unchecked</span>(<span class="number">5</span>) });</pre></div>
</div><h4 id='method.set' class="method"><code id='set.v'>pub fn <a href='#method.set' class='fnname'>set</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</code><a class='srclink' href='../../src/bitvec/slice.rs.html#698-702' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sets the bit value at the given position.</p>
<h1 id="parameters-45" class="section-header"><a href="#parameters-45">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to set. It must be in the domain
<code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be set, <code>true</code> for <code>1</code> and <code>false</code> for <code>0</code>.</li>
</ul>
<h1 id="panics-12" class="section-header"><a href="#panics-12">Panics</a></h1>
<p>This method panics if <code>index</code> is outside the slice domain.</p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="number">8u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">3</span>]);
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">3</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">3</span>]);</pre></div>
</div><h4 id='method.set_unchecked' class="method"><code id='set_unchecked.v'>pub unsafe fn <a href='#method.set_unchecked' class='fnname'>set_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</code><a class='srclink' href='../../src/bitvec/slice.rs.html#748-751' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sets a bit at an index, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.set"><code>set</code></a>.</p>
<h1 id="parameters-46" class="section-header"><a href="#parameters-46">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to retrieve. This index is <em>not</em> checked
against the length of <code>self</code>.</li>
</ul>
<h1 id="effects-2" class="section-header"><a href="#effects-2">Effects</a></h1>
<p>The bit at <code>index</code> is set to <code>value</code>.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<p>This example uses a bit slice of length 2, and demonstrates
out-of-bounds access to the last bit in the element.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>()[<span class="number">2</span> .. <span class="number">4</span>];
 <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">2</span>);
 <span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">set_unchecked</span>(<span class="number">5</span>, <span class="bool-val">true</span>); }
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">1</span>);</pre></div>
</div><h4 id='method.at' class="method"><code id='at.v'>pub fn <a href='#method.at' class='fnname'>at</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.BitGuard.html" title="struct bitvec::slice::BitGuard">BitGuard</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#826-832' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a write reference to a single bit in the slice.</p>
<p>The structure returned by this method extends the borrow until it drops,
which precludes parallel use.</p>
<p>The <a href="#method.split_at_mut"><code>split_at_mut</code></a> method allows splitting the borrows of a slice, and
will enable safe parallel use of these write references. The <code>atomic</code>
feature guarantees that parallel use does not cause data races when
modifying the underlying slice.</p>
<h1 id="lifetimes" class="section-header"><a href="#lifetimes">Lifetimes</a></h1>
<ul>
<li><code>'a</code> Propagates the lifetime of the referent slice to the single-bit
reference produced.</li>
</ul>
<h1 id="parameters-47" class="section-header"><a href="#parameters-47">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The index of the bit in <code>self</code> selected.</li>
</ul>
<h1 id="returns-33" class="section-header"><a href="#returns-33">Returns</a></h1>
<p>A write reference to the requested bit. Due to Rust limitations, this is
not a native reference type, but is a custom structure that holds the
address of the requested bit and its value. The produced structure
implements <code>Deref</code> and <code>DerefMut</code> to its cached bit, and commits the
cached bit to the parent slice on drop.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>You must use the dereference operator on the <code>.at()</code> expression in order
to assign to it. In general, you should prefer immediately using and
discarding the returned value, rather than binding it to a name and
letting it live for more than one statement.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span>]);
<span class="kw-2">*</span><span class="ident">bits</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
<span class="comment">//  note the leading dereference.</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);</pre></div>
<p>This example shows multiple usage by using <code>split_at_mut</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();

{
 <span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">a</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
 <span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">b</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">rest</span>.<span class="ident">split_at_mut</span>(<span class="number">3</span>);
 <span class="kw-2">*</span><span class="ident">a</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
 <span class="kw-2">*</span><span class="ident">b</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
 <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0b1010_0100</span>);
<span class="comment">//                               a b   rest</span></pre></div>
<p>The above example splits the slice into three (the first, the second,
and the rest) in order to hold multiple write references into the slice.</p>
</div><h4 id='method.as_ptr' class="method"><code id='as_ptr.v'>pub fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const T</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#863-870' title='goto source code'>[src]</a></h4><div class='docblock'><p>Retrieves a read pointer to the start of the underlying data slice.</p>
<h1 id="parameters-48" class="section-header"><a href="#parameters-48">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-34" class="section-header"><a href="#returns-34">Returns</a></h1>
<p>A pointer to the first element, partial or not, in the underlying store.</p>
<p>If <code>self</code> is empty, then the null pointer is returned.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>The caller must ensure that the slice outlives the pointer this function
returns, or else it will dangle and point to garbage.</p>
<p>Modifying the container referenced by this slice may cause its buffer to
reallocate, which would also make any pointers to it invalid.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>.<span class="ident">as_ptr</span>(), <span class="ident">bits</span>.<span class="ident">as_ptr</span>());</pre></div>
</div><h4 id='method.as_mut_ptr' class="method"><code id='as_mut_ptr.v'>pub fn <a href='#method.as_mut_ptr' class='fnname'>as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut T</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#902-909' title='goto source code'>[src]</a></h4><div class='docblock'><p>Retrieves a write pointer to the start of the underlying data slice.</p>
<h1 id="parameters-49" class="section-header"><a href="#parameters-49">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="returns-35" class="section-header"><a href="#returns-35">Returns</a></h1>
<p>A pointer to the first element, partial or not, in the underlying store.</p>
<p>If <code>self</code> is empty, then the null pointer is returned.</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p>The caller must ensure that the slice outlives the pointer this function
returns, or else it will dangle and point to garbage.</p>
<p>Modifying the container referenced by this slice may cause its buffer to
reallocate, which would also make any pointers to it invalid.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">src_ptr</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src_ptr</span>, <span class="ident">bits</span>.<span class="ident">as_mut_ptr</span>());</pre></div>
</div><h4 id='method.swap' class="method"><code id='swap.v'>pub fn <a href='#method.swap' class='fnname'>swap</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/slice.rs.html#936-943' title='goto source code'>[src]</a></h4><div class='docblock'><p>Swaps two bits in the slice.</p>
<h1 id="parameters-50" class="section-header"><a href="#parameters-50">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>a</code>: The first index to be swapped.</li>
<li><code>b</code>: The second index to be swapped.</li>
</ul>
<h1 id="panics-13" class="section-header"><a href="#panics-13">Panics</a></h1>
<p>Panics if either <code>a</code> or <code>b</code> are out of bounds.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="number">32u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">2</span>]);
<span class="ident">bits</span>.<span class="ident">swap</span>(<span class="number">0</span>, <span class="number">2</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">2</span>]);</pre></div>
</div><h4 id='method.reverse' class="method"><code id='reverse.v'>pub fn <a href='#method.reverse' class='fnname'>reverse</a>(&amp;mut self)</code><a class='srclink' href='../../src/bitvec/slice.rs.html#964-981' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reverses the order of bits in the slice, in place.</p>
<h1 id="parameters-51" class="section-header"><a href="#parameters-51">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b1010_1010u8</span>;
{
  <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
  <span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">7</span>].<span class="ident">reverse</span>();
}
<span class="macro">eprintln</span><span class="macro">!</span>(<span class="string">&quot;{:b}&quot;</span>, <span class="ident">src</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">0b1101_0100</span>);</pre></div>
</div><h4 id='method.iter' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>;</span></code></div></div><code id='iter.v'>pub fn <a href='#method.iter' class='fnname'>iter</a>(&amp;self) -&gt; <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1009-1011' title='goto source code'>[src]</a></h4><div class='docblock'><p>Provides read-only iteration across the slice domain.</p>
<p>The iterator returned from this method implements <code>ExactSizeIterator</code>
and <code>DoubleEndedIterator</code> just as the consuming <code>.into_iter()</code> method’s
iterator does.</p>
<h1 id="parameters-52" class="section-header"><a href="#parameters-52">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-36" class="section-header"><a href="#returns-36">Returns</a></h1>
<p>An iterator over all bits in the slice domain, in <code>C</code> and <code>T</code> ordering.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">64u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">iter</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.windows' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='windows.v'>pub fn <a href='#method.windows' class='fnname'>windows</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1045-1051' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a sliding iterator over consecutive windows in the slice. Each
windows has the width <code>size</code>. The windows overlap. If the slice is
shorter than <code>size</code>, the produced iterator is empty.</p>
<h1 id="parameters-53" class="section-header"><a href="#parameters-53">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>size</code>: The width of each window.</li>
</ul>
<h1 id="returns-37" class="section-header"><a href="#returns-37">Returns</a></h1>
<p>An iterator which yields sliding views into the slice.</p>
<h1 id="panics-14" class="section-header"><a href="#panics-14">Panics</a></h1>
<p>This function panics if the <code>size</code> is zero.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">windows</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">windows</span>(<span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">windows</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">4</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">windows</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">5</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">windows</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">6</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">windows</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">7</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">windows</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">8</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">windows</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.chunks' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='chunks.v'>pub fn <a href='#method.chunks' class='fnname'>chunks</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1084-1090' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice. Each
chunk, except possibly the last, has the width <code>size</code>. The chunks do not
overlap. If the slice is shorter than <code>size</code>, the produced iterator
produces only one chunk.</p>
<h1 id="parameters-54" class="section-header"><a href="#parameters-54">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-38" class="section-header"><a href="#returns-38">Returns</a></h1>
<p>An iterator which yields consecutive chunks of the slice.</p>
<h1 id="panics-15" class="section-header"><a href="#panics-15">Panics</a></h1>
<p>This function panics if the <code>size</code> is zero.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chunks</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chunks</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chunks</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chunks</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> .. <span class="number">8</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">chunks</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.chunks_mut' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='chunks_mut.v'>pub fn <a href='#method.chunks_mut' class='fnname'>chunks_mut</a>(&amp;mut self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1125-1131' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice. Each
chunk, except possibly the last, has the width <code>size</code>. The chunks do not
overlap. If the slice is shorter than <code>size</code>, the produced iterator
produces only one chunk.</p>
<h1 id="parameters-55" class="section-header"><a href="#parameters-55">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-39" class="section-header"><a href="#returns-39">Returns</a></h1>
<p>An iterator which yields consecutive mutable chunks of the slice.</p>
<h1 id="panics-16" class="section-header"><a href="#panics-16">Panics</a></h1>
<p>This function panics if the <code>size</code> is zero.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
 <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chunks</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_mut</span>(<span class="number">3</span>);
 <span class="ident">chunks</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">2</span>, <span class="bool-val">true</span>);
 <span class="ident">chunks</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">2</span>, <span class="bool-val">true</span>);
 <span class="ident">chunks</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">false</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">0b0110_1110</span>);</pre></div>
</div><h4 id='method.chunks_exact' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='chunks_exact.v'>pub fn <a href='#method.chunks_exact' class='fnname'>chunks_exact</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1164-1174' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice. Each
chunk has the width <code>size</code>. If <code>size</code> does not evenly divide the slice,
then the remainder is not part of the iteration, and can be accessed
separately with the <code>.remainder()</code> method.</p>
<h1 id="parameters-56" class="section-header"><a href="#parameters-56">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-40" class="section-header"><a href="#returns-40">Returns</a></h1>
<p>An iterator which yields consecutive chunks of the slice.</p>
<h1 id="panics-17" class="section-header"><a href="#panics-17">Panics</a></h1>
<p>This function panics if <code>size</code> is zero.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chunks_exact</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_exact</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chunks_exact</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chunks_exact</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">chunks_exact</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">chunks_exact</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> .. <span class="number">8</span>]);</pre></div>
</div><h4 id='method.chunks_exact_mut' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='chunks_exact_mut.v'>pub fn <a href='#method.chunks_exact_mut' class='fnname'>chunks_exact_mut</a>(&amp;mut self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1209-1219' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice. Each
chunk has the width <code>size</code>. If <code>size</code> does not evenly divide the slice,
then the remainder is not part of the iteration, and can be accessed
separately with the <code>.remainder()</code> method.</p>
<h1 id="parameters-57" class="section-header"><a href="#parameters-57">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-41" class="section-header"><a href="#returns-41">Returns</a></h1>
<p>An iterator which yields consecutive mutable chunks of the slice.</p>
<h1 id="panics-18" class="section-header"><a href="#panics-18">Panics</a></h1>
<p>This function panics if <code>size</code> is zero.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
 <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chunks_exact</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_exact_mut</span>(<span class="number">3</span>);
 <span class="ident">chunks_exact</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">2</span>, <span class="bool-val">true</span>);
 <span class="ident">chunks_exact</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">2</span>, <span class="bool-val">true</span>);
 <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">chunks_exact</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">0b0110_1111</span>);</pre></div>
</div><h4 id='method.rchunks' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='rchunks.v'>pub fn <a href='#method.rchunks' class='fnname'>rchunks</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1253-1259' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice, from
the back to the front. Each chunk, except possibly the front, has the
width <code>size</code>. The chunks do not overlap. If the slice is shorter than
<code>size</code>, then the iterator produces one item.</p>
<h1 id="parameters-58" class="section-header"><a href="#parameters-58">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-42" class="section-header"><a href="#returns-42">Returns</a></h1>
<p>An iterator which yields consecutive chunks of the slice, from the back
to the front.</p>
<h1 id="panics-19" class="section-header"><a href="#panics-19">Panics</a></h1>
<p>This function panics if <code>size</code> is zero.</p>
<h1 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rchunks</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rchunks</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> .. <span class="number">8</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rchunks</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">5</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rchunks</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">2</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rchunks</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.rchunks_mut' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='rchunks_mut.v'>pub fn <a href='#method.rchunks_mut' class='fnname'>rchunks_mut</a>(&amp;mut self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1296-1302' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice, from
the back to the front. Each chunk, except possibly the front, has the
width <code>size</code>. The chunks do not overlap. If the slice is shorter than
<code>size</code>, then the iterator produces one item.</p>
<h1 id="parameters-59" class="section-header"><a href="#parameters-59">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-43" class="section-header"><a href="#returns-43">Returns</a></h1>
<p>An iterator which yields consecutive mutable chunks of the slice, from
the back to the front.</p>
<h1 id="panics-20" class="section-header"><a href="#panics-20">Panics</a></h1>
<p>This function panics if <code>size</code> is zero.</p>
<h1 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
 <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rchunks</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_mut</span>(<span class="number">3</span>);
 <span class="ident">rchunks</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
 <span class="ident">rchunks</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">2</span>, <span class="bool-val">false</span>);
 <span class="ident">rchunks</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">false</span>);
 <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rchunks</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">0b0000_0111</span>);</pre></div>
</div><h4 id='method.rchunks_exact' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='rchunks_exact.v'>pub fn <a href='#method.rchunks_exact' class='fnname'>rchunks_exact</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1337-1345' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice, from
the back to the front. Each chunk has the width <code>size</code>. If <code>size</code> does
not evenly divide the slice, then the remainder is not part of the
iteration, and can be accessed separately with the <code>.remainder()</code>
method.</p>
<h1 id="parameters-60" class="section-header"><a href="#parameters-60">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-44" class="section-header"><a href="#returns-44">Returns</a></h1>
<p>An iterator which yields consecutive chunks of the slice, from the back
to the front.</p>
<h1 id="panics-21" class="section-header"><a href="#panics-21">Panics</a></h1>
<p>This function panics if <code>size</code> is zero.</p>
<h1 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">store</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0b0100_1011</span>];
<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">into</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rchunks_exact</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rchunks_exact</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> .. <span class="number">8</span>]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rchunks_exact</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">5</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rchunks_exact</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rchunks_exact</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">2</span>]);</pre></div>
</div><h4 id='method.rchunks_exact_mut' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, C, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, C, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;;</span></code></div></div><code id='rchunks_exact_mut.v'>pub fn <a href='#method.rchunks_exact_mut' class='fnname'>rchunks_exact_mut</a>(&amp;mut self, size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1382-1390' title='goto source code'>[src]</a></h4><div class='docblock'><p>Produces a galloping iterator over consecutive chunks in the slice, from
the back to the front. Each chunk has the width <code>size</code>. If <code>size</code> does
not evenly divide the slice, then the remainder is not part of the
iteration, and can be accessed separately with the <code>.remainder()</code>
method.</p>
<h1 id="parameters-61" class="section-header"><a href="#parameters-61">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>size</code>: The width of each chunk.</li>
</ul>
<h1 id="returns-45" class="section-header"><a href="#returns-45">Returns</a></h1>
<p>An iterator which yields consecutive mutable chunks of the slice, from
the back to the front.</p>
<h1 id="panics-22" class="section-header"><a href="#panics-22">Panics</a></h1>
<p>This function panics if <code>size</code> is zero.</p>
<h1 id="examples-57" class="section-header"><a href="#examples-57">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
 <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rchunks_exact</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact_mut</span>(<span class="number">3</span>);
 <span class="ident">rchunks_exact</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
 <span class="ident">rchunks_exact</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">set</span>(<span class="number">2</span>, <span class="bool-val">false</span>);
 <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">rchunks_exact</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">0b0100_0111</span>);</pre></div>
</div><h4 id='method.split_at' class="method"><code id='split_at.v'>pub fn <a href='#method.split_at' class='fnname'>split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1431-1440' title='goto source code'>[src]</a></h4><div class='docblock'><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h1 id="parameters-62" class="section-header"><a href="#parameters-62">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>mid</code>: The index at which to split</li>
</ul>
<h1 id="returns-46" class="section-header"><a href="#returns-46">Returns</a></h1>
<ul>
<li>The bits up to but not including <code>mid</code>.</li>
<li>The bits from mid onwards.</li>
</ul>
<h1 id="panics-23" class="section-header"><a href="#panics-23">Panics</a></h1>
<p>Panics if <code>mid &gt; self.len()</code>.</p>
<h1 id="examples-58" class="section-header"><a href="#examples-58">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">15u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();

<span class="kw">let</span> (<span class="ident">l</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">0</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">l</span>.<span class="ident">is_empty</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">r</span>, <span class="ident">bits</span>);

<span class="kw">let</span> (<span class="ident">l</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">l</span>, <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">r</span>, <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">8</span>]);

<span class="kw">let</span> (<span class="ident">l</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">8</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">l</span>, <span class="ident">bits</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">r</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id='method.split_at_mut' class="method"><code id='split_at_mut.v'>pub fn <a href='#method.split_at_mut' class='fnname'>split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1461-1464' title='goto source code'>[src]</a></h4><div class='docblock'><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h1 id="parameters-63" class="section-header"><a href="#parameters-63">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>mid</code>: The index at which to split</li>
</ul>
<h1 id="returns-47" class="section-header"><a href="#returns-47">Returns</a></h1>
<ul>
<li>The bits up to but not including <code>mid</code>.</li>
<li>The bits from mid onwards.</li>
</ul>
<h1 id="panics-24" class="section-header"><a href="#panics-24">Panics</a></h1>
<p>Panics if <code>mid &gt; self.len()</code>.</p>
</div><h4 id='method.starts_with' class="method"><code id='starts_with.v'>pub fn <a href='#method.starts_with' class='fnname'>starts_with</a>&lt;D, U&gt;(&amp;self, prefix: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;D, U&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1488-1492' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests if the slice begins with the given prefix.</p>
<h1 id="parameters-64" class="section-header"><a href="#parameters-64">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>prefix</code>: Any <code>BitSlice</code> against which <code>self</code> is tested. This is not
required to have the same cursor or storage types as <code>self</code>.</li>
</ul>
<h1 id="returns-48" class="section-header"><a href="#returns-48">Returns</a></h1>
<p>Whether <code>self</code> begins with <code>prefix</code>. This is true only if <code>self</code> is at
least as long as <code>prefix</code> and their bits are semantically equal.</p>
<h1 id="examples-59" class="section-header"><a href="#examples-59">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xA6u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">3</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> ..]));</pre></div>
</div><h4 id='method.ends_with' class="method"><code id='ends_with.v'>pub fn <a href='#method.ends_with' class='fnname'>ends_with</a>&lt;D, U&gt;(&amp;self, suffix: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;D, U&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1516-1521' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests if the slice ends with the given suffix.</p>
<h1 id="parameters-65" class="section-header"><a href="#parameters-65">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>suffix</code>: Any <code>BitSlice</code> against which <code>self</code> is tested. This is not
required to have the same cursor or storage types as <code>self</code>.</li>
</ul>
<h1 id="returns-49" class="section-header"><a href="#returns-49">Returns</a></h1>
<p>Whether <code>self</code> ends with <code>suffix</code>. This is true only if <code>self</code> is at
least as long as <code>suffix</code> and their bits are semantically equal.</p>
<h1 id="examples-60" class="section-header"><a href="#examples-60">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xA6u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> ..]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">5</span>]));</pre></div>
</div><h4 id='method.rotate_left' class="method"><code id='rotate_left.v'>pub fn <a href='#method.rotate_left' class='fnname'>rotate_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1550-1565' title='goto source code'>[src]</a></h4><div class='docblock'><p>Rotates the slice, in place, to the left.</p>
<p>After calling this method, the bits from <code>[.. by]</code> will be at the back
of the slice, and the bits from <code>[by ..]</code> will be at the front. This
operates fully in-place.</p>
<p>In-place rotation of bits requires this method to take <code>O(k × n)</code> time.
It is impossible to use machine intrinsics to perform galloping rotation
on bits.</p>
<h1 id="parameters-66" class="section-header"><a href="#parameters-66">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>by</code>: The number of bits by which to rotate left. This must be in the
range <code>0 ..= self.len()</code>. If it is <code>0</code> or <code>self.len()</code>, then this
method is a no-op.</li>
</ul>
<h1 id="examples-61" class="section-header"><a href="#examples-61">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">rotate_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>()[<span class="number">0</span>], <span class="number">0xC3</span>);</pre></div>
</div><h4 id='method.rotate_right' class="method"><code id='rotate_right.v'>pub fn <a href='#method.rotate_right' class='fnname'>rotate_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/slice.rs.html#1594-1611' title='goto source code'>[src]</a></h4><div class='docblock'><p>Rotates the slice, in place, to the right.</p>
<p>After calling this method, the bits from <code>[self.len() - by ..]</code> will be
at the front of the slice, and the bits from <code>[.. self.len() - by]</code> will
be at the back. This operates fully in-place.</p>
<p>In-place rotation of bits requires this method to take <code>O(k × n)</code> time.
It is impossible to use machine intrinsics to perform galloping rotation
on bits.</p>
<h1 id="parameters-67" class="section-header"><a href="#parameters-67">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>by</code>: The number of bits by which to rotate right. This must be in the
range <code>0 ..= self.len()</code>. If it is <code>0</code> or <code>self.len</code>, then this method
is a no-op.</li>
</ul>
<h1 id="examples-62" class="section-header"><a href="#examples-62">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">rotate_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>()[<span class="number">0</span>], <span class="number">0x3C</span>);</pre></div>
</div><h4 id='method.all' class="method"><code id='all.v'>pub fn <a href='#method.all' class='fnname'>all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1642-1686' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests if <em>all</em> bits in the slice domain are set (logical <code>∧</code>).</p>
<h1 id="truth-table" class="section-header"><a href="#truth-table">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 1
</code></pre>
<h1 id="parameters-68" class="section-header"><a href="#parameters-68">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-50" class="section-header"><a href="#returns-50">Returns</a></h1>
<p>Whether all bits in the slice domain are set. The empty slice returns
<code>true</code>.</p>
<h1 id="examples-63" class="section-header"><a href="#examples-63">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xFDu8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">all</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">all</span>());</pre></div>
</div><h4 id='method.any' class="method"><code id='any.v'>pub fn <a href='#method.any' class='fnname'>any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1717-1761' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests if <em>any</em> bit in the slice is set (logical <code>∨</code>).</p>
<h1 id="truth-table-1" class="section-header"><a href="#truth-table-1">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 1
</code></pre>
<h1 id="parameters-69" class="section-header"><a href="#parameters-69">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-51" class="section-header"><a href="#returns-51">Returns</a></h1>
<p>Whether any bit in the slice domain is set. The empty slice returns
<code>false</code>.</p>
<h1 id="examples-64" class="section-header"><a href="#examples-64">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0x40u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">any</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">any</span>());</pre></div>
</div><h4 id='method.not_all' class="method"><code id='not_all.v'>pub fn <a href='#method.not_all' class='fnname'>not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1791-1793' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests if <em>any</em> bit in the slice is unset (logical <code>¬∧</code>).</p>
<h1 id="truth-table-2" class="section-header"><a href="#truth-table-2">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 1
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-70" class="section-header"><a href="#parameters-70">Parameters</a></h1>
<ul>
<li>`&amp;self</li>
</ul>
<h1 id="returns-52" class="section-header"><a href="#returns-52">Returns</a></h1>
<p>Whether any bit in the slice domain is unset.</p>
<h1 id="examples-65" class="section-header"><a href="#examples-65">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xFDu8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">not_all</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">not_all</span>());</pre></div>
</div><h4 id='method.not_any' class="method"><code id='not_any.v'>pub fn <a href='#method.not_any' class='fnname'>not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1823-1825' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests if <em>all</em> bits in the slice are unset (logical <code>¬∨</code>).</p>
<h1 id="truth-table-3" class="section-header"><a href="#truth-table-3">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 1
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-71" class="section-header"><a href="#parameters-71">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-53" class="section-header"><a href="#returns-53">Returns</a></h1>
<p>Whether all bits in the slice domain are unset.</p>
<h1 id="examples-66" class="section-header"><a href="#examples-66">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0x40u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">not_any</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">not_any</span>());</pre></div>
</div><h4 id='method.some' class="method"><code id='some.v'>pub fn <a href='#method.some' class='fnname'>some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1860-1862' title='goto source code'>[src]</a></h4><div class='docblock'><p>Tests whether the slice has some, but not all, bits set and some, but
not all, bits unset.</p>
<p>This is <code>false</code> if either <code>all()</code> or <code>not_any()</code> are <code>true</code>.</p>
<h1 id="truth-table-4" class="section-header"><a href="#truth-table-4">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-72" class="section-header"><a href="#parameters-72">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-54" class="section-header"><a href="#returns-54">Returns</a></h1>
<p>Whether the slice domain has mixed content. The empty slice returns
<code>false</code>.</p>
<h1 id="examples-67" class="section-header"><a href="#examples-67">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0b111_000_10u8</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>].<span class="ident">some</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>].<span class="ident">some</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">6</span> ..].<span class="ident">some</span>());</pre></div>
</div><h4 id='method.count_ones' class="method"><code id='count_ones.v'>pub fn <a href='#method.count_ones' class='fnname'>count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1882-1928' title='goto source code'>[src]</a></h4><div class='docblock'><p>Counts how many bits are set high.</p>
<h1 id="parameters-73" class="section-header"><a href="#parameters-73">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-55" class="section-header"><a href="#returns-55">Returns</a></h1>
<p>The number of high bits in the slice domain.</p>
<h1 id="examples-68" class="section-header"><a href="#examples-68">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> [<span class="number">0xFDu8</span>, <span class="number">0x25</span>].<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">count_ones</span>(), <span class="number">10</span>);</pre></div>
</div><h4 id='method.count_zeros' class="method"><code id='count_zeros.v'>pub fn <a href='#method.count_zeros' class='fnname'>count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#1948-1994' title='goto source code'>[src]</a></h4><div class='docblock'><p>Counts how many bits are set low.</p>
<h1 id="parameters-74" class="section-header"><a href="#parameters-74">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-56" class="section-header"><a href="#returns-56">Returns</a></h1>
<p>The number of low bits in the slice domain.</p>
<h1 id="examples-69" class="section-header"><a href="#examples-69">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> [<span class="number">0xFDu8</span>, <span class="number">0x25</span>].<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">count_zeros</span>(), <span class="number">6</span>);</pre></div>
</div><h4 id='method.set_all' class="method"><code id='set_all.v'>pub fn <a href='#method.set_all' class='fnname'>set_all</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)</code><a class='srclink' href='../../src/bitvec/slice.rs.html#2017-2058' title='goto source code'>[src]</a></h4><div class='docblock'><p>Set all bits in the slice to a value.</p>
<h1 id="parameters-75" class="section-header"><a href="#parameters-75">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>value</code>: The bit value to which all bits in the slice will be set.</li>
</ul>
<h1 id="examples-70" class="section-header"><a href="#examples-70">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">6</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0011_1100</span>]);
<span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">5</span>].<span class="ident">set_all</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0010_0100</span>]);
<span class="ident">bits</span>[.. <span class="number">1</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b1010_0100</span>]);</pre></div>
</div><h4 id='method.for_each' class="method"><code id='for_each.v'>pub fn <a href='#method.for_each' class='fnname'>for_each</a>&lt;F&gt;(&amp;mut self, func: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2086-2092' title='goto source code'>[src]</a></h4><div class='docblock'><p>Provides mutable traversal of the collection.</p>
<p>It is impossible to implement <code>IndexMut</code> on <code>BitSlice</code>, because bits do
not have addresses, so there can be no <code>&amp;mut u1</code>. This method allows the
client to receive an enumerated bit, and provide a new bit to set at
each index.</p>
<h1 id="parameters-76" class="section-header"><a href="#parameters-76">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>func</code>: A function which receives a <code>(usize, bool)</code> pair of index and
value, and returns a bool. It receives the bit at each position, and
the return value is written back at that position.</li>
</ul>
<h1 id="examples-71" class="section-header"><a href="#examples-71">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
 <span class="ident">bits</span>.<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">idx</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">idx</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">0b1001_0010</span>);</pre></div>
</div><h4 id='method.add_assign_reverse-1' class="method"><code id='add_assign_reverse.v-1'>pub fn <a href='#method.add_assign_reverse-1' class='fnname'>add_assign_reverse</a>&lt;I&gt;(&amp;mut self, addend: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2152-2168' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs “reverse” addition (left to right instead of right to left).</p>
<p>This addition interprets the slice, and the other addend, as having its
least significant bits first in the order and its most significant bits
last. This is most likely to be numerically useful under a
<code>LittleEndian</code> <code>Cursor</code> type.</p>
<h1 id="parameters-77" class="section-header"><a href="#parameters-77">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code>: The addition uses <code>self</code> as one addend, and writes the
sum back into <code>self</code>.</li>
<li><code>addend: impl IntoIterator&lt;Item=bool&gt;</code>: A stream of bits. When this is
another <code>BitSlice</code>, iteration proceeds from left to right.</li>
</ul>
<h1 id="return" class="section-header"><a href="#return">Return</a></h1>
<p>The final carry bit is returned</p>
<h1 id="effects-3" class="section-header"><a href="#effects-3">Effects</a></h1>
<p>Starting from index <code>0</code> and proceeding upwards until either <code>self</code> or
<code>addend</code> expires, the carry-propagated addition of <code>self[i]</code> and
<code>addend[i]</code> is written to <code>self[i]</code>.</p>
<pre><code class="language-text">  101111
+ 0010__ (the two missing bits are logically zero)
--------
  100000 1 (the carry-out is returned)
</code></pre>
<h1 id="examples-72" class="section-header"><a href="#examples-72">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">0b0000_1010u8</span>;
<span class="kw">let</span>     <span class="ident">b</span> <span class="op">=</span> <span class="number">0b0000_1100u8</span>;
<span class="comment">//      s =      1 0110</span>
<span class="kw">let</span> <span class="ident">ab</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">LittleEndian</span><span class="op">&gt;</span>()[.. <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="op">&amp;</span>    <span class="ident">b</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">LittleEndian</span><span class="op">&gt;</span>()[.. <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">ab</span>.<span class="ident">add_assign_reverse</span>(<span class="ident">bb</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">c</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ab</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0b0000_0110u8</span>);</pre></div>
<h1 id="performance-notes" class="section-header"><a href="#performance-notes">Performance Notes</a></h1>
<p>When using <code>LittleEndian</code> <code>Cursor</code> types, this can be accelerated by
delegating the addition to the underlying types. This is a software
implementation of the <a href="https://en.wikipedia.org/wiki/Ripple-carry_adder">ripple-carry adder</a>, which has <code>O(n)</code> runtime in
the number of bits. The CPU is much faster, as it has access to
element-wise or vectorized addition operations.</p>
<p>If your use case sincerely needs binary-integer arithmetic operations on
bit sets</p>
</div><h4 id='method.as_slice' class="method"><code id='as_slice.v'>pub fn <a href='#method.as_slice' class='fnname'>as_slice</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[T]</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2195-2197' title='goto source code'>[src]</a></h4><div class='docblock'><p>Accesses the backing storage of the <code>BitSlice</code> as a slice of its
elements.</p>
<h1 id="parameters-78" class="section-header"><a href="#parameters-78">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-57" class="section-header"><a href="#returns-57">Returns</a></h1>
<p>A slice of all the elements that the <code>BitSlice</code> uses for storage.</p>
<h1 id="examples-73" class="section-header"><a href="#examples-73">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">66</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="ident">accum</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_slice</span>()
  .<span class="ident">iter</span>()
  .<span class="ident">map</span>(<span class="op">|</span><span class="ident">elt</span><span class="op">|</span> <span class="ident">elt</span>.<span class="ident">count_ones</span>())
  .<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">accum</span>, <span class="number">3</span>);</pre></div>
</div><h4 id='method.as_mut_slice' class="method"><code id='as_mut_slice.v'>pub fn <a href='#method.as_mut_slice' class='fnname'>as_mut_slice</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [T]</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2213-2215' title='goto source code'>[src]</a></h4><div class='docblock'><p>Accesses the underlying store.</p>
<h1 id="examples-74" class="section-header"><a href="#examples-74">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">64</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="kw">for</span> <span class="ident">elt</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">as_mut_slice</span>() {
  <span class="kw-2">*</span><span class="ident">elt</span> <span class="op">|</span><span class="op">=</span> <span class="number">2</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">66</span>], <span class="ident">bits</span>.<span class="ident">as_slice</span>());</pre></div>
</div><h4 id='method.change_cursor-1' class="method"><code id='change_cursor.v-1'>pub fn <a href='#method.change_cursor-1' class='fnname'>change_cursor</a>&lt;D&gt;(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;D, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2242-2245' title='goto source code'>[src]</a></h4><div class='docblock'><p>Changes the cursor type of the slice handle.</p>
<h1 id="parameters-79" class="section-header"><a href="#parameters-79">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-58" class="section-header"><a href="#returns-58">Returns</a></h1>
<p>An equivalent slice handle with a new cursor type.</p>
<h1 id="type-parameters-2" class="section-header"><a href="#type-parameters-2">Type Parameters</a></h1>
<ul>
<li><code>D: Cursor</code> The new cursor type to use for the handle.</li>
</ul>
<h1 id="examples-75" class="section-header"><a href="#examples-75">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">2u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">as_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">6</span>]);
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">change_cursor</span>::<span class="op">&lt;</span><span class="ident">LittleEndian</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">1</span>]);</pre></div>
</div><h4 id='method.change_cursor_mut' class="method"><code id='change_cursor_mut.v'>pub fn <a href='#method.change_cursor_mut' class='fnname'>change_cursor_mut</a>&lt;D&gt;(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;D, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,&nbsp;</span></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2274-2277' title='goto source code'>[src]</a></h4><div class='docblock'><p>Changes the cursor type of the slice handle.</p>
<h1 id="parameters-80" class="section-header"><a href="#parameters-80">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="returns-59" class="section-header"><a href="#returns-59">Returns</a></h1>
<p>An equivalent slice handle with a new cursor type.</p>
<h1 id="type-parameters-3" class="section-header"><a href="#type-parameters-3">Type Parameters</a></h1>
<ul>
<li><code>D: Cursor</code> The new cursor type to use for the handle.</li>
</ul>
<h1 id="examples-76" class="section-header"><a href="#examples-76">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw-2">*</span><span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>().<span class="ident">at</span>(<span class="number">1</span>) <span class="op">=</span> <span class="bool-val">true</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">64</span>);
<span class="ident">src</span>.<span class="ident">as_mut_bitslice</span>::<span class="op">&lt;</span><span class="ident">BigEndian</span><span class="op">&gt;</span>()
   .<span class="ident">change_cursor_mut</span>::<span class="op">&lt;</span><span class="ident">LittleEndian</span><span class="op">&gt;</span>()
   .<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="number">66</span>);</pre></div>
</div><h4 id='method.bitptr-1' class="method"><code id='bitptr.v-1'>pub fn <a href='#method.bitptr-1' class='fnname'>bitptr</a>(&amp;self) -&gt; BitPtr&lt;T&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#2290-2292' title='goto source code'>[src]</a></h4><div class='docblock'><p>Accesses the underlying pointer structure.</p>
<h1 id="parameters-81" class="section-header"><a href="#parameters-81">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-60" class="section-header"><a href="#returns-60">Returns</a></h1>
<p>The <a href="../pointer/struct.BitPtr.html"><code>BitPtr</code></a> structure of the slice handle.</p>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Send' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2222-2223' title='goto source code'>[src]</a></h3><div class='docblock'><p><code>BitVec</code> is safe to move across thread boundaries, as is <code>&amp;mut BitVec</code>.</p>
</div><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Sync' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2226-2227' title='goto source code'>[src]</a></h3><div class='docblock'><p><code>&amp;BitVec</code> is safe to move across thread boundaries.</p>
</div><div class='impl-items'></div><h3 id='impl-Drop' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Drop' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2556-2565' title='goto source code'>[src]</a></h3><div class='docblock'><p>Readies the underlying storage for Drop.</p>
</div><div class='impl-items'><h4 id='method.drop' class="method"><code id='drop.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2559-2564' title='goto source code'>[src]</a></h4><div class='docblock'><p>Rebuild the interior <code>Vec</code> and let it run the deallocator.</p>
</div></div><h3 id='impl-AsRef%3CBitSlice%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-AsRef%3CBitSlice%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1920-1925' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.as_ref' class="method hidden"><code id='as_ref.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1922-1924' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-AsRef%3C%5BT%5D%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-AsRef%3C%5BT%5D%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1929-1944' title='goto source code'>[src]</a></h3><div class='docblock'><p>Gives read access to all live elements in the underlying storage, including
the partially-filled tail.</p>
</div><div class='impl-items'><h4 id='method.as_ref-1' class="method"><code id='as_ref.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[T]</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1941-1943' title='goto source code'>[src]</a></h4><div class='docblock'><p>Accesses the underlying store.</p>
<h1 id="examples-77" class="section-header"><a href="#examples-77">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0b1000_0000</span>], <span class="ident">bv</span>.<span class="ident">as_slice</span>());</pre></div>
</div></div><h3 id='impl-AsMut%3CBitSlice%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-AsMut%3CBitSlice%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1904-1909' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.as_mut' class="method hidden"><code id='as_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html#tymethod.as_mut' class='fnname'>as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1906-1908' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-AsMut%3C%5BT%5D%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-AsMut%3C%5BT%5D%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1913-1918' title='goto source code'>[src]</a></h3><div class='docblock'><p>Gives write access to all live elements in the underlying storage, including
the partially-filled tail.</p>
</div><div class='impl-items'><h4 id='method.as_mut-1' class="method hidden"><code id='as_mut.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html#tymethod.as_mut' class='fnname'>as_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [T]</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1915-1917' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CBox%3C%5BT%5D%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Into%3CBox%3C%5BT%5D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1985-1990' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1987-1989' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CVec%3CT%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Into%3CVec%3CT%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2004-2009' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into-1' class="method hidden"><code id='into.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2006-2008' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3CBitVec%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-From%3CBitVec%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/boxed.rs.html#608-613' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(src: <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/boxed.rs.html#610-612' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3C%26%27_%20BitSlice%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;'_, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-From%3C%26%27_%20BitSlice%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1946-1951' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-1' class="method hidden"><code id='from.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(src: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1948-1950' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3C%26%27_%20%5Bbool%5D%3E' class='impl'><code class='in-band'>impl&lt;'_, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-From%3C%26%27_%20%5Bbool%5D%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1957-1962' title='goto source code'>[src]</a></h3><div class='docblock'><p>Builds a <code>BitVec</code> out of a slice of <code>bool</code>.</p>
<p>This is primarily for the <code>bitvec!</code> macro; it is not recommended for general
use.</p>
</div><div class='impl-items'><h4 id='method.from-2' class="method hidden"><code id='from.v-2'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1959-1961' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3CBitBox%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../bitvec/boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-From%3CBitBox%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1964-1969' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-3' class="method hidden"><code id='from.v-3'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(src: <a class="struct" href="../../bitvec/boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;C, T&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1966-1968' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3C%26%27_%20%5BT%5D%3E' class='impl'><code class='in-band'>impl&lt;'_, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [T]</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-From%3C%26%27_%20%5BT%5D%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1971-1976' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-4' class="method hidden"><code id='from.v-4'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[T]</a>) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1973-1975' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3CBox%3C%5BT%5D%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-From%3CBox%3C%5BT%5D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1978-1983' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-5' class="method hidden"><code id='from.v-5'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(src: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1980-1982' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3CVec%3CT%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-From%3CVec%3CT%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1997-2002' title='goto source code'>[src]</a></h3><div class='docblock'><p>Builds a <code>BitVec</code> out of a <code>Vec</code> of elements.</p>
<p>This moves the memory as-is from the source buffer into the new <code>BitVec</code>.
The source buffer will be unchanged by this operation, so you don't need to
worry about using the correct cursor type.</p>
</div><div class='impl-items'><h4 id='method.from-6' class="method hidden"><code id='from.v-6'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(src: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1999-2001' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Extend%3Cbool%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Extend%3Cbool%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2114-2145' title='goto source code'>[src]</a></h3><div class='docblock'><p>Extends a <code>BitVec</code> with the contents of another bitstream.</p>
<p>At present, this just calls <code>.push()</code> in a loop. When specialization becomes
available, it will be able to more intelligently perform bulk moves from the
source into <code>self</code> when the source is <code>BitSlice</code>-compatible.</p>
</div><div class='impl-items'><h4 id='method.extend' class="method"><code id='extend.v'>fn <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html#tymethod.extend' class='fnname'>extend</a>&lt;I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;&gt;(&amp;mut self, src: I)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2137-2144' title='goto source code'>[src]</a></h4><div class='docblock'><p>Extends a <code>BitVec</code> from another bitstream.</p>
<h1 id="parameters-82" class="section-header"><a href="#parameters-82">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>src</code>: A source bitstream.</li>
</ul>
<h1 id="type-parameters-4" class="section-header"><a href="#type-parameters-4">Type Parameters</a></h1>
<ul>
<li><code>I: IntoIterator&lt;Item=bool&gt;</code>: The source bitstream with which to
extend <code>self</code>.</li>
</ul>
<h1 id="examples-78" class="section-header"><a href="#examples-78">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">4</span>];
<span class="ident">bv</span>.<span class="ident">extend</span>(<span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0x0F</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);</pre></div>
</div></div><h3 id='impl-IntoIterator' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IntoIterator' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2184-2209' title='goto source code'>[src]</a></h3><div class='docblock'><p>Produces an iterator over all the bits in the vector.</p>
<p>This iterator follows the ordering in the vector type, and implements
<code>ExactSizeIterator</code>, since <code>BitVec</code>s always know exactly how large they are,
and <code>DoubleEndedIterator</code>, since they have known ends.</p>
</div><div class='impl-items'><h4 id='associatedtype.Item' class="type"><code id='Item.t'>type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id='associatedtype.IntoIter' class="type"><code id='IntoIter.t'>type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter' class="type">IntoIter</a> = <a class="struct" href="../../bitvec/vec/struct.IntoIter.html" title="struct bitvec::vec::IntoIter">IntoIter</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id='method.into_iter' class="method"><code id='into_iter.v'>fn <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter' class='fnname'>into_iter</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2203-2208' title='goto source code'>[src]</a></h4><div class='docblock'><p>Iterates over the vector.</p>
<h1 id="examples-79" class="section-header"><a href="#examples-79">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">for</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">bv</span> {
  <span class="kw">if</span> <span class="ident">bit</span> { <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>; }
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">count</span>, <span class="number">4</span>);</pre></div>
</div></div><h3 id='impl-IntoIterator-1' class='impl'><code class='in-band'>impl&lt;'a, C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IntoIterator-1' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2211-2219' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Item-1' class="type"><code id='Item.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id='associatedtype.IntoIter-1' class="type"><code id='IntoIter.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter' class="type">IntoIter</a> = &lt;&amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id='method.into_iter-1' class="method hidden"><code id='into_iter.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter' class='fnname'>into_iter</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2216-2218' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><h3 id='impl-Clone' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1749-1781' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code id='clone.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1751-1762' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method hidden"><code id='clone_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1764-1780' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Default' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Default' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2011-2016' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.default' class="method hidden"><code id='default.v'>fn <a href='https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2013-2015' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id='impl-Eq' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Eq' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1783-1784' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Ord' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Ord' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1786-1791' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.cmp' class="method hidden"><code id='cmp.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp' class='fnname'>cmp</a>(&amp;self, rhs: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1788-1790' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div><h4 id='method.max' class="method hidden"><code id='max.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max' class='fnname'>max</a>(self, other: Self) -&gt; Self</code><span class='since' title='Stable since Rust version 1.21.0'>1.21.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#569-572' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max">Read more</a></p>
</div><h4 id='method.min' class="method hidden"><code id='min.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min' class='fnname'>min</a>(self, other: Self) -&gt; Self</code><span class='since' title='Stable since Rust version 1.21.0'>1.21.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#586-589' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min">Read more</a></p>
</div><h4 id='method.clamp' class="method hidden"><code id='clamp.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp' class='fnname'>clamp</a>(self, min: Self, max: Self) -&gt; Self</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#610-620' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>clamp</code>)</div></div><div class='docblock hidden'><p>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></div><h3 id='impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E' class='impl'><code class='in-band'>impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/slice.rs.html#2381-2386' title='goto source code'>[src]</a></h3><div class='docblock'><p>Allow comparison against the allocated form.</p>
</div><div class='impl-items'><h4 id='method.eq' class="method hidden"><code id='eq.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2383-2385' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne' class="method hidden"><code id='ne.v'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#208' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-1' class='impl'><code class='in-band'>impl&lt;'_, A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for &amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-1' class='anchor'></a><a class='srclink' href='../../src/bitvec/slice.rs.html#2389-2394' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq-1' class="method hidden"><code id='eq.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/slice.rs.html#2391-2393' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-1' class="method hidden"><code id='ne.v-1'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#208' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-2' class='impl'><code class='in-band'>impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-2' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1799-1837' title='goto source code'>[src]</a></h3><div class='docblock'><p>Tests if two <code>BitVec</code>s are semantically — not bitwise — equal.</p>
<p>It is valid to compare two vectors of different cursor or element types.</p>
<p>The equality condition requires that they have the same number of stored
bits and that each pair of bits in semantic order are identical.</p>
</div><div class='impl-items'><h4 id='method.eq-2' class="method"><code id='eq.v-2'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1834-1836' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs a comparison by <code>==</code>.</p>
<h1 id="parameters-83" class="section-header"><a href="#parameters-83">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>rhs</code>: The other vector to compare.</li>
</ul>
<h1 id="returns-61" class="section-header"><a href="#returns-61">Returns</a></h1>
<p>Whether the vectors compare equal.</p>
<h1 id="examples-80" class="section-header"><a href="#examples-80">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">l</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">LittleEndian</span>, <span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">LittleEndian</span>, <span class="ident">u16</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">r</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u32</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">l</span> <span class="op">=</span><span class="op">=</span> <span class="ident">r</span>);</pre></div>
<p>This example uses the same types to prove that raw, bitwise, values are
not used for equality comparison.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">l</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">r</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">LittleEndian</span>, <span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">LittleEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">l</span>, <span class="ident">r</span>);
<span class="macro">assert_ne</span><span class="macro">!</span>(<span class="ident">l</span>.<span class="ident">as_slice</span>(), <span class="ident">r</span>.<span class="ident">as_slice</span>());</pre></div>
</div><h4 id='method.ne-2' class="method hidden"><code id='ne.v-2'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#208' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-PartialEq%3CBitSlice%3CC%2C%20D%3E%3E' class='impl'><code class='in-band'>impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialEq%3CBitSlice%3CC%2C%20D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1839-1844' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq-3' class="method hidden"><code id='eq.v-3'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1841-1843' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-3' class="method hidden"><code id='ne.v-3'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#208' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-PartialEq%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E' class='impl'><code class='in-band'>impl&lt;'_, A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialEq%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1846-1851' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq-4' class="method hidden"><code id='eq.v-4'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#1848-1850' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-4' class="method hidden"><code id='ne.v-4'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#208' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E' class='impl'><code class='in-band'>impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/slice.rs.html#2457-2462' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.partial_cmp' class="method hidden"><code id='partial_cmp.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#2459-2461' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id='method.lt' class="method hidden"><code id='lt.v'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#798-803' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le' class="method hidden"><code id='le.v'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#820-825' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt' class="method hidden"><code id='gt.v'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#841-846' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge' class="method hidden"><code id='ge.v'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#863-868' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id='impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-1' class='impl'><code class='in-band'>impl&lt;'_, A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for &amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-1' class='anchor'></a><a class='srclink' href='../../src/bitvec/slice.rs.html#2465-2470' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.partial_cmp-1' class="method hidden"><code id='partial_cmp.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class='srclink' href='../../src/bitvec/slice.rs.html#2467-2469' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id='method.lt-1' class="method hidden"><code id='lt.v-1'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#798-803' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le-1' class="method hidden"><code id='le.v-1'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#820-825' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt-1' class="method hidden"><code id='gt.v-1'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#841-846' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge-1' class="method hidden"><code id='ge.v-1'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#863-868' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id='impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-2' class='impl'><code class='in-band'>impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-2' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1861-1888' title='goto source code'>[src]</a></h3><div class='docblock'><p>Compares two <code>BitVec</code>s by semantic — not bitwise — ordering.</p>
<p>The comparison sorts by testing each index for one vector to have a set bit
where the other vector has an unset bit. If the vectors are different, the
vector with the set bit sorts greater than the vector with the unset bit.</p>
<p>If one of the vectors is exhausted before they differ, the longer vector is
greater.</p>
</div><div class='impl-items'><h4 id='method.partial_cmp-2' class="method"><code id='partial_cmp.v-2'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1885-1887' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs a comparison by <code>&lt;</code> or <code>&gt;</code>.</p>
<h1 id="parameters-84" class="section-header"><a href="#parameters-84">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>rhs</code>: The other vector to compare.</li>
</ul>
<h1 id="returns-62" class="section-header"><a href="#returns-62">Returns</a></h1>
<p>The relative ordering of the two vectors.</p>
<h1 id="examples-81" class="section-header"><a href="#examples-81">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span> <span class="op">&lt;</span> <span class="ident">b</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">b</span> <span class="op">&lt;</span> <span class="ident">c</span>);</pre></div>
</div><h4 id='method.lt-2' class="method hidden"><code id='lt.v-2'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#798-803' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le-2' class="method hidden"><code id='le.v-2'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#820-825' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt-2' class="method hidden"><code id='gt.v-2'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#841-846' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge-2' class="method hidden"><code id='ge.v-2'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#863-868' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id='impl-PartialOrd%3CBitSlice%3CC%2C%20D%3E%3E' class='impl'><code class='in-band'>impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialOrd%3CBitSlice%3CC%2C%20D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1890-1895' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.partial_cmp-3' class="method hidden"><code id='partial_cmp.v-3'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1892-1894' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id='method.lt-3' class="method hidden"><code id='lt.v-3'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#798-803' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le-3' class="method hidden"><code id='le.v-3'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#820-825' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt-3' class="method hidden"><code id='gt.v-3'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#841-846' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge-3' class="method hidden"><code id='ge.v-3'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#863-868' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id='impl-PartialOrd%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E' class='impl'><code class='in-band'>impl&lt;'_, A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-PartialOrd%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1897-1902' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.partial_cmp-4' class="method hidden"><code id='partial_cmp.v-4'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1899-1901' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id='method.lt-4' class="method hidden"><code id='lt.v-4'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#798-803' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le-4' class="method hidden"><code id='le.v-4'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#820-825' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt-4' class="method hidden"><code id='gt.v-4'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#841-846' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge-4' class="method hidden"><code id='ge.v-4'><span class="docblock attributes">#[must_use]
</span>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#863-868' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id='impl-Display' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Display' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2065-2080' title='goto source code'>[src]</a></h3><div class='docblock'><p>Prints the <code>BitVec</code> for displaying.</p>
<p>This prints each element in turn, formatted in binary in semantic order (so
the first bit seen is printed first and the last bit seen printed last).
Each element of storage is separated by a space for ease of reading.</p>
<p>The alternate character <code>{:#}</code> prints each element on its own line.</p>
<p>To see the in-memory representation, use <code>AsRef</code> to get access to the raw
elements and print that slice instead.</p>
</div><div class='impl-items'><h4 id='method.fmt' class="method"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2077-2079' title='goto source code'>[src]</a></h4><div class='docblock'><p>Renders the <code>BitVec</code> contents for display.</p>
<h1 id="examples-82" class="section-header"><a href="#examples-82">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[01001011, 01]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));</pre></div>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2028-2053' title='goto source code'>[src]</a></h3><div class='docblock'><p>Prints the <code>BitVec</code> for debugging.</p>
<p>The output is of the form <code>BitVec&lt;C, T&gt; [ELT, *]</code>, where <code>&lt;C, T&gt;</code> is the
cursor and element type, with square brackets on each end of the bits and
all the live elements in the vector printed in binary. The printout is
always in semantic order, and may not reflect the underlying store. To see
the underlying store, use <code>format!(&quot;{:?}&quot;, self.as_slice());</code> instead.</p>
<p>The alternate character <code>{:#?}</code> prints each element on its own line, rather
than separated by a space.</p>
</div><div class='impl-items'><h4 id='method.fmt-1' class="method"><code id='fmt.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2045-2052' title='goto source code'>[src]</a></h4><div class='docblock'><p>Renders the <code>BitVec</code> type header and contents for debug.</p>
<h1 id="examples-83" class="section-header"><a href="#examples-83">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">LittleEndian</span>, <span class="ident">u16</span>;
  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>
];
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="string">&quot;BitVec&lt;LittleEndian, u16&gt; [0101000011110101]&quot;</span>,
  <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">bv</span>)
);</pre></div>
</div></div><h3 id='impl-Sub%3CBitVec%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Sub%3CBitVec%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#3027-3071' title='goto source code'>[src]</a></h3><div class='docblock'><p>Subtracts one <code>BitVec</code> from another assuming 2’s-complement encoding.</p>
<p>Subtraction is a more complex operation than addition. The bit-level work is
largely the same, but semantic distinctions must be made. Unlike addition,
which is commutative and tolerant of switching the order of the addends,
subtraction cannot swap the minuend (LHS) and subtrahend (RHS).</p>
<p>Because of the properties of 2’s-complement arithmetic, M - S is equivalent
to M + (!S + 1). Subtraction therefore bitflips the subtrahend and adds one.
This may, in a degenerate case, cause the subtrahend to increase in length.</p>
<p>Once the subtrahend is stable, the minuend zero-extends its left side in
order to match the length of the subtrahend if needed (this is provided by
the <code>&gt;&gt;</code> operator).</p>
<p>When the minuend is stable, the minuend and subtrahend are added together
by the <code>&lt;BitVec as Add&gt;</code> implementation. The output will be encoded in
2’s-complement, so a leading one means that the output is considered
negative.</p>
<p>Interpreting the contents of a <code>BitVec</code> as an integer is beyond the scope of
this crate.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output' class="type"><code id='Output.t'>type <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id='method.sub' class="method"><code id='sub.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub' class='fnname'>sub</a>(self, subtrahend: Self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" title="type core::ops::arith::Sub::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#3067-3070' title='goto source code'>[src]</a></h4><div class='docblock'><p>Subtracts one <code>BitVec</code> from another.</p>
<h1 id="examples-84" class="section-header"><a href="#examples-84">Examples</a></h1>
<p>Minuend larger than subtrahend, positive difference.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[   <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>], <span class="ident">c</span>);</pre></div>
<p>Minuend smaller than subtrahend, negative difference.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[   <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>], <span class="ident">c</span>);</pre></div>
<p>Subtraction from self is correctly handled.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">clone</span>();
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">c</span>.<span class="ident">not_any</span>(), <span class="string">&quot;{:?}&quot;</span>, <span class="ident">c</span>);</pre></div>
</div></div><h3 id='impl-Add%3CBitVec%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Add%3CBitVec%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2244-2276' title='goto source code'>[src]</a></h3><div class='docblock'><p>Adds two <code>BitVec</code>s together, zero-extending the shorter.</p>
<p><code>BitVec</code> addition works just like adding numbers longhand on paper. The
first bits in the <code>BitVec</code> are the highest, so addition works from right to
left, and the shorter <code>BitVec</code> is assumed to be extended to the left with
zero.</p>
<p>The output <code>BitVec</code> may be one bit longer than the longer input, if addition
overflowed.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-1' class="type"><code id='Output.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div><h4 id='method.add' class="method"><code id='add.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add' class='fnname'>add</a>(self, addend: Self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" title="type core::ops::arith::Add::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2272-2275' title='goto source code'>[src]</a></h4><div class='docblock'><p>Adds two <code>BitVec</code>s.</p>
<h1 id="examples-85" class="section-header"><a href="#examples-85">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="ident">s</span>);</pre></div>
<p>This example demonstrates the addition of differently-sized <code>BitVec</code>s,
and will overflow.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">b</span> <span class="op">+</span> <span class="ident">a</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="ident">s</span>);</pre></div>
</div></div><h3 id='impl-Neg' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html" title="trait core::ops::arith::Neg">Neg</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Neg' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2710-2735' title='goto source code'>[src]</a></h3><div class='docblock'><p>2’s-complement negation of a <code>BitVec</code>.</p>
<p>In 2’s-complement, negation is defined as bit-inversion followed by adding
one.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-2' class="type"><code id='Output.t-2'>type <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div><h4 id='method.neg' class="method"><code id='neg.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html#tymethod.neg' class='fnname'>neg</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Neg.html#associatedtype.Output" title="type core::ops::arith::Neg::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2725-2734' title='goto source code'>[src]</a></h4><div class='docblock'><p>Numerically negates a <code>BitVec</code> using 2’s-complement arithmetic.</p>
<h1 id="examples-86" class="section-header"><a href="#examples-86">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ne</span> <span class="op">=</span> <span class="op">-</span><span class="ident">bv</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ne</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div></div><h3 id='impl-AddAssign%3CBitVec%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-AddAssign%3CBitVec%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2293-2330' title='goto source code'>[src]</a></h3><div class='docblock'><p>Adds another <code>BitVec</code> into <code>self</code>, zero-extending the shorter.</p>
<p><code>BitVec</code> addition works just like adding numbers longhand on paper. The
first bits in the <code>BitVec</code> are the highest, so addition works from right to
left, and the shorter <code>BitVec</code> is assumed to be extended to the left with
zero.</p>
<p>The output <code>BitVec</code> may be one bit longer than the longer input, if addition
overflowed.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class='impl-items'><h4 id='method.add_assign' class="method"><code id='add_assign.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html#tymethod.add_assign' class='fnname'>add_assign</a>(&amp;mut self, addend: Self)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2307-2329' title='goto source code'>[src]</a></h4><div class='docblock'><p>Adds another <code>BitVec</code> into <code>self</code>.</p>
<h1 id="examples-87" class="section-header"><a href="#examples-87">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">a</span> <span class="op">+</span><span class="op">=</span> <span class="ident">b</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre></div>
</div></div><h3 id='impl-SubAssign%3CBitVec%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-SubAssign%3CBitVec%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#3085-3131' title='goto source code'>[src]</a></h3><div class='docblock'><p>Subtracts another <code>BitVec</code> from <code>self</code>, assuming 2’s-complement encoding.</p>
<p>The minuend is zero-extended, or the subtrahend sign-extended, as needed to
ensure that the vectors are the same width before subtraction occurs.</p>
<p>The <code>Sub</code> trait has more documentation on the subtraction process.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class='impl-items'><h4 id='method.sub_assign' class="method"><code id='sub_assign.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign' class='fnname'>sub_assign</a>(&amp;mut self, subtrahend: Self)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#3100-3130' title='goto source code'>[src]</a></h4><div class='docblock'><p>Subtracts another <code>BitVec</code> from <code>self</code>.</p>
<h1 id="examples-88" class="section-header"><a href="#examples-88">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">c</span>, <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div></div><h3 id='impl-Not' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Not' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2738-2757' title='goto source code'>[src]</a></h3><div class='docblock'><p>Flips all bits in the vector.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-3' class="type"><code id='Output.t-3'>type <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>!</code> operator.</p>
</div><h4 id='method.not' class="method"><code id='not.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#tymethod.not' class='fnname'>not</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2753-2756' title='goto source code'>[src]</a></h4><div class='docblock'><p>Inverts all bits in the vector.</p>
<h1 id="examples-89" class="section-header"><a href="#examples-89">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">BigEndian</span>, <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span>[<span class="number">0u32</span>] <span class="kw">as</span> <span class="kw-2">&amp;</span>[<span class="ident">u32</span>]);
<span class="kw">let</span> <span class="ident">flip</span> <span class="op">=</span> <span class="op">!</span><span class="ident">bv</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="op">!</span><span class="number">0u32</span>, <span class="ident">flip</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);</pre></div>
</div></div><h3 id='impl-BitAnd%3CI%3E' class='impl'><code class='in-band'>impl&lt;C, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;I&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a href='#impl-BitAnd%3CI%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2337-2357' title='goto source code'>[src]</a></h3><div class='docblock'><p>Performs the Boolean <code>AND</code> operation between each element of a <code>BitVec</code> and
anything that can provide a stream of <code>bool</code> values (such as another
<code>BitVec</code>, or any <code>bool</code> generator of your choice). The <code>BitVec</code> emitted will
have the length of the shorter sequence of bits -- if one is longer than the
other, the extra bits will be ignored.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-4' class="type"><code id='Output.t-4'>type <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>&amp;</code> operator.</p>
</div><h4 id='method.bitand' class="method"><code id='bitand.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#tymethod.bitand' class='fnname'>bitand</a>(self, rhs: I) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#associatedtype.Output" title="type core::ops::bit::BitAnd::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2353-2356' title='goto source code'>[src]</a></h4><div class='docblock'><p><code>AND</code>s a vector and a bitstream, producing a new vector.</p>
<h1 id="examples-90" class="section-header"><a href="#examples-90">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">lhs</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">rhs</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">and</span> <span class="op">=</span> <span class="ident">lhs</span> <span class="op">&amp;</span> <span class="ident">rhs</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0001]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">and</span>));</pre></div>
</div></div><h3 id='impl-BitOr%3CI%3E' class='impl'><code class='in-band'>impl&lt;C, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;I&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a href='#impl-BitOr%3CI%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2396-2416' title='goto source code'>[src]</a></h3><div class='docblock'><p>Performs the Boolean <code>OR</code> operation between each element of a <code>BitVec</code> and
anything that can provide a stream of <code>bool</code> values (such as another
<code>BitVec</code>, or any <code>bool</code> generator of your choice). The <code>BitVec</code> emitted will
have the length of the shorter sequence of bits -- if one is longer than the
other, the extra bits will be ignored.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-5' class="type"><code id='Output.t-5'>type <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>|</code> operator.</p>
</div><h4 id='method.bitor' class="method"><code id='bitor.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#tymethod.bitor' class='fnname'>bitor</a>(self, rhs: I) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#associatedtype.Output" title="type core::ops::bit::BitOr::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2412-2415' title='goto source code'>[src]</a></h4><div class='docblock'><p><code>OR</code>s a vector and a bitstream, producing a new vector.</p>
<h1 id="examples-91" class="section-header"><a href="#examples-91">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">lhs</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">rhs</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">or</span>  <span class="op">=</span> <span class="ident">lhs</span> <span class="op">|</span> <span class="ident">rhs</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">or</span>));</pre></div>
</div></div><h3 id='impl-BitXor%3CI%3E' class='impl'><code class='in-band'>impl&lt;C, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;I&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a href='#impl-BitXor%3CI%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2455-2475' title='goto source code'>[src]</a></h3><div class='docblock'><p>Performs the Boolean <code>XOR</code> operation between each element of a <code>BitVec</code> and
anything that can provide a stream of <code>bool</code> values (such as another
<code>BitVec</code>, or any <code>bool</code> generator of your choice). The <code>BitVec</code> emitted will
have the length of the shorter sequence of bits -- if one is longer than the
other, the extra bits will be ignored.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-6' class="type"><code id='Output.t-6'>type <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>^</code> operator.</p>
</div><h4 id='method.bitxor' class="method"><code id='bitxor.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#tymethod.bitxor' class='fnname'>bitxor</a>(self, rhs: I) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#associatedtype.Output" title="type core::ops::bit::BitXor::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2471-2474' title='goto source code'>[src]</a></h4><div class='docblock'><p><code>XOR</code>s a vector and a bitstream, producing a new vector.</p>
<h1 id="examples-92" class="section-header"><a href="#examples-92">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">lhs</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">rhs</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">xor</span> <span class="op">=</span> <span class="ident">lhs</span> <span class="op">^</span> <span class="ident">rhs</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0110]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">xor</span>));</pre></div>
</div></div><h3 id='impl-Shl%3Cusize%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shl.html" title="trait core::ops::bit::Shl">Shl</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Shl%3Cusize%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2789-2813' title='goto source code'>[src]</a></h3><div class='docblock'><p>Shifts all bits in the vector to the left – <strong>DOWN AND TOWARDS THE FRONT</strong>.</p>
<p>On primitives, the left-shift operator <code>&lt;&lt;</code> moves bits away from origin and
towards the ceiling. This is because we label the bits in a primitive with
the minimum on the right and the maximum on the left, which is big-endian
bit order. This increases the value of the primitive being shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on
the right! Thus, left-shifting moves bits towards the <strong>minimum</strong>.</p>
<p>In BigEndian order, the effect in memory will be what you expect the <code>&lt;&lt;</code>
operator to do.</p>
<p><strong>In LittleEndian order, the effect will be equivalent to using <code>&gt;&gt;</code> on</strong>
<strong>the primitives in memory!</strong></p>
<h1 id="notes-3" class="section-header"><a href="#notes-3">Notes</a></h1>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than
left to their old value.</p>
<p>The length of the vector is decreased by the shift amount.</p>
<p>If the shift amount is greater than the length, the vector calls <code>clear()</code>
and zeroes its memory. This is <em>not</em> an error.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-7' class="type"><code id='Output.t-7'>type <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shl.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>&lt;&lt;</code> operator.</p>
</div><h4 id='method.shl' class="method"><code id='shl.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shl.html#tymethod.shl' class='fnname'>shl</a>(self, shamt: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shl.html#associatedtype.Output" title="type core::ops::bit::Shl::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2809-2812' title='goto source code'>[src]</a></h4><div class='docblock'><p>Shifts a <code>BitVec</code> to the left, shortening it.</p>
<h1 id="examples-93" class="section-header"><a href="#examples-93">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b0001_1100</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="kw">let</span> <span class="ident">ls</span> <span class="op">=</span> <span class="ident">bv</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="number">2usize</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">ls</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b0111_0000</span>, <span class="ident">ls</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ls</span>.<span class="ident">len</span>(), <span class="number">4</span>);</pre></div>
</div></div><h3 id='impl-Shr%3Cusize%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shr.html" title="trait core::ops::bit::Shr">Shr</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Shr%3Cusize%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2909-2934' title='goto source code'>[src]</a></h3><div class='docblock'><p>Shifts all bits in the vector to the right – <strong>UP AND TOWARDS THE BACK</strong>.</p>
<p>On primitives, the right-shift operator <code>&gt;&gt;</code> moves bits towards the origin
and away from the ceiling. This is because we label the bits in a primitive
with the minimum on the right and the maximum on the left, which is
big-endian bit order. This decreases the value of the primitive being
shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on
the right! Thus, right-shifting moves bits towards the <strong>maximum</strong>.</p>
<p>In BigEndian order, the effect in memory will be what you expect the <code>&gt;&gt;</code>
operator to do.</p>
<p><strong>In LittleEndian order, the effect will be equivalent to using <code>&lt;&lt;</code> on</strong>
<strong>the primitives in memory!</strong></p>
<h1 id="notes-4" class="section-header"><a href="#notes-4">Notes</a></h1>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than
left to their old value.</p>
<p>The length of the vector is increased by the shift amount.</p>
<p>If the new length of the vector would overflow, a panic occurs. This <em>is</em> an
error.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-8' class="type"><code id='Output.t-8'>type <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shr.html#associatedtype.Output' class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>&gt;&gt;</code> operator.</p>
</div><h4 id='method.shr' class="method"><code id='shr.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shr.html#tymethod.shr' class='fnname'>shr</a>(self, shamt: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Shr.html#associatedtype.Output" title="type core::ops::bit::Shr::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2930-2933' title='goto source code'>[src]</a></h4><div class='docblock'><p>Shifts a <code>BitVec</code> to the right, lengthening it and filling the front
with 0.</p>
<h1 id="examples-94" class="section-header"><a href="#examples-94">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b0001_1100</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="kw">let</span> <span class="ident">rs</span> <span class="op">=</span> <span class="ident">bv</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="number">2usize</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[00000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">rs</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b0000_0111</span>, <span class="ident">rs</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rs</span>.<span class="ident">len</span>(), <span class="number">8</span>);</pre></div>
</div></div><h3 id='impl-BitAndAssign%3CI%3E' class='impl'><code class='in-band'>impl&lt;C, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;I&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a href='#impl-BitAndAssign%3CI%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2362-2389' title='goto source code'>[src]</a></h3><div class='docblock'><p>Performs the Boolean <code>AND</code> operation in place on a <code>BitVec</code>, using a stream
of <code>bool</code> values as the other bit for each operation. If the other stream is
shorter than <code>self</code>, <code>self</code> will be truncated when the other stream expires.</p>
</div><div class='impl-items'><h4 id='method.bitand_assign' class="method"><code id='bitand_assign.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign' class='fnname'>bitand_assign</a>(&amp;mut self, rhs: I)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2375-2388' title='goto source code'>[src]</a></h4><div class='docblock'><p><code>AND</code>s another bitstream into a vector.</p>
<h1 id="examples-95" class="section-header"><a href="#examples-95">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span>  <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
        <span class="ident">src</span> <span class="kw-2">&amp;</span><span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0001]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">src</span>));</pre></div>
</div></div><h3 id='impl-BitOrAssign%3CI%3E' class='impl'><code class='in-band'>impl&lt;C, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;I&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a href='#impl-BitOrAssign%3CI%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2421-2448' title='goto source code'>[src]</a></h3><div class='docblock'><p>Performs the Boolean <code>OR</code> operation in place on a <code>BitVec</code>, using a stream
of <code>bool</code> values as the other bit for each operation. If the other stream is
shorter than <code>self</code>, <code>self</code> will be truncated when the other stream expires.</p>
</div><div class='impl-items'><h4 id='method.bitor_assign' class="method"><code id='bitor_assign.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign' class='fnname'>bitor_assign</a>(&amp;mut self, rhs: I)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2434-2447' title='goto source code'>[src]</a></h4><div class='docblock'><p><code>OR</code>s another bitstream into a vector.</p>
<h1 id="examples-96" class="section-header"><a href="#examples-96">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span>  <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
        <span class="ident">src</span> <span class="op">|</span><span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">src</span>));</pre></div>
</div></div><h3 id='impl-BitXorAssign%3CI%3E' class='impl'><code class='in-band'>impl&lt;C, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;I&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code><a href='#impl-BitXorAssign%3CI%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2480-2507' title='goto source code'>[src]</a></h3><div class='docblock'><p>Performs the Boolean <code>XOR</code> operation in place on a <code>BitVec</code>, using a stream
of <code>bool</code> values as the other bit for each operation. If the other stream is
shorter than <code>self</code>, <code>self</code> will be truncated when the other stream expires.</p>
</div><div class='impl-items'><h4 id='method.bitxor_assign' class="method"><code id='bitxor_assign.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign' class='fnname'>bitxor_assign</a>(&amp;mut self, rhs: I)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2493-2506' title='goto source code'>[src]</a></h4><div class='docblock'><p><code>XOR</code>s another bitstream into a vector.</p>
<h1 id="examples-97" class="section-header"><a href="#examples-97">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span>  <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
        <span class="ident">src</span> <span class="op">^</span><span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0110]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">src</span>));</pre></div>
</div></div><h3 id='impl-ShlAssign%3Cusize%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.ShlAssign.html" title="trait core::ops::bit::ShlAssign">ShlAssign</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-ShlAssign%3Cusize%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2843-2878' title='goto source code'>[src]</a></h3><div class='docblock'><p>Shifts all bits in the vector to the left – <strong>DOWN AND TOWARDS THE FRONT</strong>.</p>
<p>On primitives, the left-shift operator <code>&lt;&lt;</code> moves bits away from origin and
towards the ceiling. This is because we label the bits in a primitive with
the minimum on the right and the maximum on the left, which is big-endian
bit order. This increases the value of the primitive being shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on
the right! Thus, left-shifting moves bits towards the <strong>minimum</strong>.</p>
<p>In BigEndian order, the effect in memory will be what you expect the <code>&lt;&lt;</code>
operator to do.</p>
<p><strong>In LittleEndian order, the effect will be equivalent to using <code>&gt;&gt;</code> on</strong>
<strong>the primitives in memory!</strong></p>
<h1 id="notes-5" class="section-header"><a href="#notes-5">Notes</a></h1>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than
left to their old value.</p>
<p>The length of the vector is decreased by the shift amount.</p>
<p>If the shift amount is greater than the length, the vector calls <code>clear()</code>
and zeroes its memory. This is <em>not</em> an error.</p>
</div><div class='impl-items'><h4 id='method.shl_assign' class="method"><code id='shl_assign.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.ShlAssign.html#tymethod.shl_assign' class='fnname'>shl_assign</a>(&amp;mut self, shamt: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2861-2877' title='goto source code'>[src]</a></h4><div class='docblock'><p>Shifts a <code>BitVec</code> to the left in place, shortening it.</p>
<h1 id="examples-98" class="section-header"><a href="#examples-98">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">LittleEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b0011_1000</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="ident">bv</span> <span class="op">&lt;</span><span class="op">&lt;</span><span class="op">=</span> <span class="number">2</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b0000_1110</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">4</span>);</pre></div>
</div></div><h3 id='impl-ShrAssign%3Cusize%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.ShrAssign.html" title="trait core::ops::bit::ShrAssign">ShrAssign</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-ShrAssign%3Cusize%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2965-2997' title='goto source code'>[src]</a></h3><div class='docblock'><p>Shifts all bits in the vector to the right – <strong>UP AND TOWARDS THE BACK</strong>.</p>
<p>On primitives, the right-shift operator <code>&gt;&gt;</code> moves bits towards the origin
and away from the ceiling. This is because we label the bits in a primitive
with the minimum on the right and the maximum on the left, which is
big-endian bit order. This decreases the value of the primitive being
shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on
the right! Thus, right-shifting moves bits towards the <strong>maximum</strong>.</p>
<p>In BigEndian order, the effect in memory will be what you expect the <code>&gt;&gt;</code>
operator to do.</p>
<p><strong>In LittleEndian order, the effect will be equivalent to using <code>&lt;&lt;</code> on</strong>
<strong>the primitives in memory!</strong></p>
<h1 id="notes-6" class="section-header"><a href="#notes-6">Notes</a></h1>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than
left to their old value.</p>
<p>The length of the vector is increased by the shift amount.</p>
<p>If the new length of the vector would overflow, a panic occurs. This <em>is</em> an
error.</p>
</div><div class='impl-items'><h4 id='method.shr_assign' class="method"><code id='shr_assign.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/bit/trait.ShrAssign.html#tymethod.shr_assign' class='fnname'>shr_assign</a>(&amp;mut self, shamt: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2984-2996' title='goto source code'>[src]</a></h4><div class='docblock'><p>Shifts a <code>BitVec</code> to the right in place, lengthening it and filling the
front with 0.</p>
<h1 id="examples-99" class="section-header"><a href="#examples-99">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">LittleEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b0011_1000</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="ident">bv</span> <span class="op">&gt;</span><span class="op">&gt;</span><span class="op">=</span> <span class="number">2</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;[00000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0b1110_0000</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">8</span>);</pre></div>
</div></div><h3 id='impl-Deref' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Deref' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2512-2530' title='goto source code'>[src]</a></h3><div class='docblock'><p>Reborrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<p>This mimics the separation between <code>Vec&lt;T&gt;</code> and <code>[T]</code>.</p>
</div><div class='impl-items'><h4 id='associatedtype.Target' class="type"><code id='Target.t'>type <a href='https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target' class="type">Target</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>The resulting type after dereferencing.</p>
</div><h4 id='method.deref' class="method"><code id='deref.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref' class='fnname'>deref</a>(&amp;self) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2527-2529' title='goto source code'>[src]</a></h4><div class='docblock'><p>Dereferences <code>&amp;BitVec</code> down to <code>&amp;BitSlice</code>.</p>
<h1 id="examples-100" class="section-header"><a href="#examples-100">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">bref</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">bv</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bref</span>[<span class="number">2</span>]);</pre></div>
</div></div><h3 id='impl-DerefMut' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-DerefMut' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2535-2553' title='goto source code'>[src]</a></h3><div class='docblock'><p>Mutably reborrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<p>This mimics the separation between <code>Vec&lt;T&gt;</code> and <code>[T]</code>.</p>
</div><div class='impl-items'><h4 id='method.deref_mut' class="method"><code id='deref_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut' class='fnname'>deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2550-2552' title='goto source code'>[src]</a></h4><div class='docblock'><p>Dereferences <code>&amp;mut BitVec</code> down to <code>&amp;mut BitSlice</code>.</p>
<h1 id="examples-101" class="section-header"><a href="#examples-101">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">6</span>];
<span class="kw">let</span> <span class="ident">bref</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">bv</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bref</span>[<span class="number">5</span>]);
<span class="ident">bref</span>.<span class="ident">set</span>(<span class="number">5</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bref</span>[<span class="number">5</span>]);</pre></div>
</div></div><h3 id='impl-Index%3Cusize%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Index%3Cusize%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2569-2602' title='goto source code'>[src]</a></h3><div class='docblock'><p>Gets the bit at a specific index. The index must be less than the length of
the <code>BitVec</code>.</p>
</div><div class='impl-items'><h4 id='associatedtype.Output-9' class="type"><code id='Output.t-9'>type <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output' class="type">Output</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id='method.index' class="method"><code id='index.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, cursor: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2599-2601' title='goto source code'>[src]</a></h4><div class='docblock'><p>Looks up a single bit by semantic count.</p>
<h1 id="examples-102" class="section-header"><a href="#examples-102">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="ident">BigEndian</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bv</span>[<span class="number">7</span>]); <span class="comment">// ---------------------------------^  |  |</span>
<span class="macro">assert</span><span class="macro">!</span>( <span class="ident">bv</span>[<span class="number">8</span>]); <span class="comment">// ------------------------------------^  |</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bv</span>[<span class="number">9</span>]); <span class="comment">// ---------------------------------------^</span></pre></div>
<p>If the index is greater than or equal to the length, indexing will
panic.</p>
<p>The below test will panic when accessing index 1, as only index 0 is
valid.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="ident">new</span>();
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="ident">bv</span>[<span class="number">1</span>];</pre></div>
</div></div><h3 id='impl-Index%3CRange%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Index%3CRange%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2604-2611' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Output-10' class="type"><code id='Output.t-10'>type <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output' class="type">Output</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id='method.index-1' class="method hidden"><code id='index.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2608-2610' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-Index%3CRangeFrom%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Index%3CRangeFrom%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2620-2627' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Output-11' class="type"><code id='Output.t-11'>type <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output' class="type">Output</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id='method.index-2' class="method hidden"><code id='index.v-2'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2624-2626' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-Index%3CRangeFull%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Index%3CRangeFull%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2636-2643' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Output-12' class="type"><code id='Output.t-12'>type <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output' class="type">Output</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id='method.index-3' class="method hidden"><code id='index.v-3'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, _: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2640-2642' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-Index%3CRangeInclusive%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Index%3CRangeInclusive%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2652-2659' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Output-13' class="type"><code id='Output.t-13'>type <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output' class="type">Output</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id='method.index-4' class="method hidden"><code id='index.v-4'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2656-2658' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-Index%3CRangeTo%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Index%3CRangeTo%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2668-2675' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Output-14' class="type"><code id='Output.t-14'>type <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output' class="type">Output</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id='method.index-5' class="method hidden"><code id='index.v-5'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2672-2674' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-Index%3CRangeToInclusive%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Index%3CRangeToInclusive%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2684-2691' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Output-15' class="type"><code id='Output.t-15'>type <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output' class="type">Output</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id='method.index-6' class="method hidden"><code id='index.v-6'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index' class='fnname'>index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2688-2690' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-IndexMut%3CRange%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IndexMut%3CRange%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2613-2618' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.index_mut' class="method hidden"><code id='index_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut' class='fnname'>index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2615-2617' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-IndexMut%3CRangeFrom%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2629-2634' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.index_mut-1' class="method hidden"><code id='index_mut.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut' class='fnname'>index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2631-2633' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-IndexMut%3CRangeFull%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IndexMut%3CRangeFull%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2645-2650' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.index_mut-2' class="method hidden"><code id='index_mut.v-2'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut' class='fnname'>index_mut</a>(&amp;mut self, _: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2647-2649' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2661-2666' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.index_mut-3' class="method hidden"><code id='index_mut.v-3'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut' class='fnname'>index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2663-2665' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-IndexMut%3CRangeTo%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IndexMut%3CRangeTo%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2677-2682' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.index_mut-4' class="method hidden"><code id='index_mut.v-4'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut' class='fnname'>index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2679-2681' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2693-2698' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.index_mut-5' class="method hidden"><code id='index_mut.v-5'>fn <a href='https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut' class='fnname'>index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class='srclink' href='../../src/bitvec/vec.rs.html#2695-2697' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id='impl-Hash' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Hash' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2083-2094' title='goto source code'>[src]</a></h3><div class='docblock'><p>Writes the contents of the <code>BitVec</code>, in semantic bit order, into a hasher.</p>
</div><div class='impl-items'><h4 id='method.hash' class="method"><code id='hash.v'>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, hasher: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>H)</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2091-2093' title='goto source code'>[src]</a></h4><div class='docblock'><p>Writes each bit of the <code>BitVec</code>, as a full <code>bool</code>, into the hasher.</p>
<h1 id="parameters-85" class="section-header"><a href="#parameters-85">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>hasher</code>: The hashing pool into which the vector is written.</li>
</ul>
</div><h4 id='method.hash_slice' class="method hidden"><code id='hash_slice.v'>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.3.0'>1.3.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#192-198' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 id='impl-FromIterator%3Cbool%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-FromIterator%3Cbool%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2149-2177' title='goto source code'>[src]</a></h3><div class='docblock'><p>Permits the construction of a <code>BitVec</code> by using <code>.collect()</code> on an iterator
of <code>bool</code>.</p>
</div><div class='impl-items'><h4 id='method.from_iter' class="method"><code id='from_iter.v'>fn <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter' class='fnname'>from_iter</a>&lt;I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;&gt;(src: I) -&gt; Self</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2165-2176' title='goto source code'>[src]</a></h4><div class='docblock'><p>Collects an iterator of <code>bool</code> into a vector.</p>
<h1 id="examples-103" class="section-header"><a href="#examples-103">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">repeat</span>;
<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">repeat</span>(<span class="bool-val">true</span>)
  .<span class="ident">take</span>(<span class="number">4</span>)
  .<span class="ident">chain</span>(<span class="ident">repeat</span>(<span class="bool-val">false</span>).<span class="ident">take</span>(<span class="number">4</span>))
  .<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0xF0</span>);</pre></div>
</div></div><h3 id='impl-Borrow%3CBitSlice%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Borrow%3CBitSlice%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1692-1717' title='goto source code'>[src]</a></h3><div class='docblock'><p>Signifies that <code>BitSlice</code> is the borrowed form of <code>BitVec</code>.</p>
</div><div class='impl-items'><h4 id='method.borrow' class="method"><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1714-1716' title='goto source code'>[src]</a></h4><div class='docblock'><p>Borrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<h1 id="parameters-86" class="section-header"><a href="#parameters-86">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-63" class="section-header"><a href="#returns-63">Returns</a></h1>
<p>A borrowed <code>BitSlice</code> of the vector.</p>
<h1 id="examples-104" class="section-header"><a href="#examples-104">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">borrow</span>::<span class="ident">Borrow</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">13</span>];
<span class="kw">let</span> <span class="ident">bs</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">borrow</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bs</span>[<span class="number">10</span>]);</pre></div>
</div></div><h3 id='impl-BorrowMut%3CBitSlice%3CC%2C%20T%3E%3E' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;&gt; for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CBitSlice%3CC%2C%20T%3E%3E' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#1720-1747' title='goto source code'>[src]</a></h3><div class='docblock'><p>Signifies that <code>BitSlice</code> is the borrowed form of <code>BitVec</code>.</p>
</div><div class='impl-items'><h4 id='method.borrow_mut' class="method"><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, T&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#1744-1746' title='goto source code'>[src]</a></h4><div class='docblock'><p>Mutably borrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<h1 id="parameters-87" class="section-header"><a href="#parameters-87">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="returns-64" class="section-header"><a href="#returns-64">Returns</a></h1>
<p>A mutably borrowed <code>BitSlice</code> of the vector.</p>
<h1 id="examples-105" class="section-header"><a href="#examples-105">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">borrow</span>::<span class="ident">BorrowMut</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">13</span>];
<span class="kw">let</span> <span class="ident">bs</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">borrow_mut</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bs</span>[<span class="number">10</span>]);
<span class="ident">bs</span>.<span class="ident">set</span>(<span class="number">10</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bs</span>[<span class="number">10</span>]);</pre></div>
</div></div><h3 id='impl-Write' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../../bitvec/cursor/trait.Cursor.html" title="trait bitvec::cursor::Cursor">Cursor</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href='#impl-Write' class='anchor'></a><a class='srclink' href='../../src/bitvec/vec.rs.html#2097-2107' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.write' class="method hidden"><code id='write.v'>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.write' class='fnname'>write</a>(&amp;mut self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2099-2104' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Write a buffer into this writer, returning how many bytes were written. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.write">Read more</a></p>
</div><h4 id='method.flush' class="method hidden"><code id='flush.v'>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.flush' class='fnname'>flush</a>(&amp;mut self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</code><a class='srclink' href='../../src/bitvec/vec.rs.html#2106' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Flush this output stream, ensuring that all intermediately buffered contents reach their destination. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.flush">Read more</a></p>
</div><h4 id='method.write_vectored' class="method hidden"><code id='write_vectored.v'>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_vectored' class='fnname'>write_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="struct" href="https://doc.rust-lang.org/nightly/std/io/struct.IoSlice.html" title="struct std::io::IoSlice">IoSlice</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</code><span class='since' title='Stable since Rust version 1.36.0'>1.36.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1278-1280' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Like <code>write</code>, except that it writes from a slice of buffers. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_vectored">Read more</a></p>
</div><h4 id='method.write_all' class="method hidden"><code id='write_all.v'>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all' class='fnname'>write_all</a>(&amp;mut self, buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1339-1350' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Attempts to write an entire buffer into this writer. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all">Read more</a></p>
</div><h4 id='method.write_fmt' class="method hidden"><code id='write_fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt' class='fnname'>write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html" title="struct core::fmt::Arguments">Arguments</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1391-1423' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Writes a formatted string into this writer, returning any error encountered. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt">Read more</a></p>
</div><h4 id='method.by_ref' class="method hidden"><code id='by_ref.v'>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.by_ref' class='fnname'>by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/std/io/mod.rs.html#1447' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates a &quot;by reference&quot; adaptor for this instance of <code>Write</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.by_ref">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href='#impl-Unpin' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,&nbsp;</span></code><a href='#impl-UnwindSafe' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-RefUnwindSafe' class='impl'><code class='in-band'>impl&lt;C, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../../bitvec/vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></code><a href='#impl-RefUnwindSafe' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#544-549' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into-2' class="method hidden"><code id='into.v-2'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#546-548' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#553-555' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-7' class="method hidden"><code id='from.v-7'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#554' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-IntoIterator-2' class='impl'><code class='in-band'>impl&lt;I&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>,&nbsp;</span></code><a href='#impl-IntoIterator-2' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#242-249' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Item-2' class="type"><code id='Item.t-2'>type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item' class="type">Item</a> = &lt;I as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a></code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id='associatedtype.IntoIter-2' class="type"><code id='IntoIter.t-2'>type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter' class="type">IntoIter</a> = I</code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id='method.into_iter-2' class="method hidden"><code id='into_iter.v-2'>fn <a href='https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter' class='fnname'>into_iter</a>(self) -&gt; I</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/iter/traits/collect.rs.html#246-248' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><h3 id='impl-ToOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned' class="type"><code id='Owned.t'>type <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned' class="method hidden"><code id='to_owned.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into' class="method hidden"><code id='clone_into.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id='impl-ToString' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-ToString' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2166-2176' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_string' class="method hidden"><code id='to_string.v'>default fn <a href='https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string' class='fnname'>to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2168-2175' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#584-590' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#587-589' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#572-579' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#576-578' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow-1' class="method hidden"><code id='borrow.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut-1' class="method hidden"><code id='borrow_mut.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#98-100' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#99' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "bitvec";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>